{"version":3,"file":"bbscript-parser.min.js","sources":["../../bbcode-src/bbscript/bbscript1/utils.js","../../bbcode-src/bbscript/logger.js","../../bbcode-src/bbscript/bbscript1/processor.js","../../bbcode-src/bbscript/bbscript1/functions.js","../../bbcode-src/bbscript/bbscript2/AST.js","../../bbcode-src/bbscript/bbscript2/ASTError.js","../../bbcode-src/bbscript/bbscript2/parser.js","../../bbcode-src/bbscript/bbscript2/processor.js","../../bbcode-src/bbscript/bbscript2/functions.js","../../bbcode-src/bbscript/index.js","../../bbcode-src/bbscript/bbscript1/bbscript1.js","../../bbcode-src/bbscript/bbscript2/bbscript2.js"],"sourcesContent":["/** @typedef {import('./processor').bbscriptOptions} bbscriptOptions */\n\n/**\n * @typedef {Object.<string, bbscriptFunc>} bbscriptFuncMap\n */\n/**\n * @typedef {Object} bbscriptFunc\n * @property {{types: bbscriptParamTypes[], default?: (number|string|null)}} params\n * @property {bbscriptFunctionCallback} func\n */\n/**\n * @callback bbscriptFunctionCallback\n * @param {bbscriptOptions} options\n * @param {...any} args\n * @returns {(void | string | boolean | number | Promise<void> | bbscriptStop)}\n */\n/**\n * @typedef {Object} bbscriptStop\n * @property {'stop'} msg\n */\n\nexport const bbscriptParamTypes = Object.freeze({\n  Function: Symbol(\"Function\"),\n  String: Symbol(\"String\"),\n  Identifier: Symbol(\"Identifier\"),\n  Int: Symbol(\"Int\"),\n});\n\n/**\n * @param {unknown} input\n * @returns {asserts input is bbscriptStop}\n */\nexport const isStop = (input) => {\n  return (\n    typeof input === \"object\" &&\n    Object.getOwnPropertyNames(input).includes(\"msg\") &&\n    input.msg === \"stop\"\n  );\n};\n\n/**\n * @typedef {Object} astNode\n * @property {string} name\n * @property {(astNode|string|number)[]} params\n */\n\n/**\n * @param {unknown} input\n * @returns {asserts input is astNode}\n */\nexport const isAstNode = (input) => {\n  return (\n    typeof input === \"object\" &&\n    Object.getOwnPropertyNames(input).every((v) => [\"name\", \"params\"].includes(v))\n  );\n};\n/**\n * Process input string to produce either a string or the associated data if it is a variable\n * @param {string | number} str input string. Either a string or an identifier\n * @param {bbscriptOptions} options\n * @returns {string} string value\n */\nexport const getStringVal = (str, options) => {\n  if (typeof str === \"string\" && str.match(/^_(.*)_$/)) {\n    if (\n      options.callerId &&\n      options.data[options.callerId] &&\n      options.data[options.callerId][str] !== undefined\n    ) {\n      // is identifier\n      return options.data[options.callerId][str];\n    } else {\n      return str.match(/^_(.*)_$/)?.[1] || str;\n    }\n  }\n  if (typeof str === \"string\" && str.match(/\\$\\{\\w+\\}/)) {\n    const matches = str.matchAll(/\\$\\{(\\w+)\\}/g);\n    for (const match of matches) {\n      const presumedValue = options.data?.[options.callerId]?.[\"_\" + match[1] + \"_\"] || match[0];\n      str = str.replace(match[0], presumedValue);\n    }\n  }\n  return str;\n};\n","/* eslint-disable no-console */\nexport class ConsoleLogger {\n  static log = console.log;\n  static warn = console.warn;\n  static error = console.error;\n  static info = console.info;\n  static debug = console.debug;\n}\n","/** @typedef {import('./utils').astNode} astNode */\n/** @typedef {import('./utils').bbscriptFuncMap} bbscriptFuncMap */\nimport { bbscriptParamTypes, isStop } from \"./utils\";\nimport { ConsoleLogger } from \"../logger\";\n\n/**\n * @typedef {Object} bbscriptOptions\n * @property {string} callerId\n * @property {string} callerClass\n * @property {any} data\n * @property {BBScriptProcessor} processor\n * @property {Element} target\n */\n\nexport class BBScriptProcessor {\n  /** @type {bbscriptOptions} */\n  options;\n  /** @type {bbscriptFuncMap} */\n  functions;\n  /**\n   * @param {bbscriptFuncMap} bbscriptFunc\n   * @param {bbscriptOptions} [defaultOptions={} as bbscriptOptions]\n   */\n  constructor(bbscriptFunc, defaultOptions = {}) {\n    defaultOptions = {\n      ...defaultOptions,\n      processor: this,\n    };\n    this.options = defaultOptions;\n    this.functions = bbscriptFunc;\n  }\n  /**\n   * Processes and executes all commands in node tree\n   * @param {astNode[]} nodeTree input node tree, generated by `parse()`\n   * @param {string} callerId\n   * @param {string} callerClass\n   * @param {bbscriptOptions} [options=this.options] options to use\n   * @returns {Promise<void>}\n   */\n  async execAll(nodeTree, callerId, callerClass, options = this.options) {\n    options = {\n      ...this.options,\n      ...options,\n      callerId,\n      callerClass,\n    };\n    for (const node of nodeTree) {\n      const res = await this.exec(node, options);\n      if (isStop(res)) {\n        return;\n      }\n    }\n  }\n  /**\n   * Processes and executes a single node\n   * @param {astNode} node node to process and execute\n   * @param {bbscriptOptions} options bbscript options\n   * @returns {(void|string|boolean|number|Promise<void>|import('./utils').bbscriptStop)} returns value if applicable\n   */\n  exec(node, options) {\n    const functions = options.processor.functions;\n    const callable = functions[node.name].func;\n    if (callable) {\n      const args = node.params;\n      try {\n        return callable(options, ...args);\n      } catch (error) {\n        ConsoleLogger.warn(\"BBScript Error\", error, node.name, options);\n      }\n    } else {\n      ConsoleLogger.info(\"invalid command\", node.name, options);\n    }\n  }\n  /**\n   * Process raw string into AST\n   * @param {string} raw input script\n   * @returns {astNode[]}\n   */\n  parse(raw) {\n    const nodeTree = [];\n    for (let line of raw.split(\"\\n\")) {\n      line = line.trim();\n      if (!line || line.startsWith(\"//\")) {\n        continue;\n      }\n      try {\n        nodeTree.push(this.process(this.functions, line)[0]);\n      } catch (e) {\n        ConsoleLogger.warn(e);\n      }\n    }\n    return nodeTree;\n  }\n  /**\n   * Processes input line into AST node\n   * @private\n   * @param {bbscriptFuncMap} functions valid bbscript functions\n   * @param {string} input input string to process\n   * @param {number} [idx=0] optional index of string to start from\n   * @returns {[astNode, number]} parsed AST Node and last index\n   */\n  process(functions, input, idx = 0) {\n    const [part1, ...parts] = input.split(/\\s+/);\n    const name = part1.toLowerCase();\n    const params = parts.join(\" \");\n    const node = {\n      name,\n      params: [],\n    };\n    if (!(name in functions)) {\n      throw new Error(`Invalid bbscript function name '${name}'`);\n    }\n    const foundFunc = functions[name];\n    // required params\n    for (const { types: validParamType, default: defaultValue } of foundFunc.params) {\n      let value;\n      if (idx >= params.length) {\n        if (defaultValue) {\n          value = defaultValue;\n        } else if (defaultValue == null) {\n          // optional param with function defined default\n          continue;\n        } else {\n          ConsoleLogger.warn(`Missing Parameter for ${name}`, validParamType);\n          continue;\n        }\n      }\n      let isString = false;\n      if (params[idx] === '\"') {\n        // process quoted string\n        [value, idx] = this.getEnclosedParameter(params, idx);\n        isString = true;\n      } else if (params[idx] === \"'\") {\n        // process quoted string\n        [value, idx] = this.getEnclosedParameter(params, idx, \"'\");\n        isString = true;\n      } else if (validParamType.includes(bbscriptParamTypes.Function) && params[idx] === \"(\") {\n        // process nested function\n        try {\n          const [childFunc, overallIdx] = this.getEnclosedParameter(params, idx, \")\");\n          [value] = this.process(functions, childFunc);\n          idx = overallIdx;\n        } catch (e) {\n          ConsoleLogger.warn(e);\n        }\n      } else if (validParamType.includes(bbscriptParamTypes.Identifier) && params[idx] === \"$\") {\n        let braceVar = false;\n        try {\n          braceVar = params[idx + 1] === \"{\";\n        } catch {\n          ConsoleLogger.warn(`$ found but no opening {`);\n        }\n        if (braceVar) {\n          [value, idx] = this.getEnclosedParameter(params, ++idx, \"}\");\n        }\n      } else if (params[idx]) {\n        // no clue what token is\n        value = params.substring(idx).split(/\\s+/, 2)[0];\n        idx += value.length;\n      }\n      if (\n        validParamType.includes(bbscriptParamTypes.Int) &&\n        typeof value === \"string\" &&\n        !isNaN(parseFloat(value))\n      ) {\n        // if numeric, convert it\n        value = parseFloat(value);\n      } else if (validParamType.includes(bbscriptParamTypes.String) && isString) {\n        value;\n      } else if (validParamType.includes(bbscriptParamTypes.Identifier)) {\n        value = `_${value}_`;\n      }\n      if (value !== undefined && value !== null) {\n        node.params.push(value);\n      }\n      while (params[idx]?.match(/\\s/)) {\n        // skip index to next non-space char\n        idx++;\n      }\n    }\n    return [node, idx];\n  }\n  /**\n   * Processed an input string for a single block of string\n   * @private\n   * @param {string} input input string\n   * @param {number} idx index to start from\n   * @param {string} [close='\"'] closing char to stop at\n   * @param {boolean} [trimWrap=true] if `true`, will remove opening and closing chars\n   * @returns {[string, number]} found parameter and closing index\n   */\n  getEnclosedParameter(input, idx, close = '\"', trimWrap = true) {\n    const startIdx = idx;\n    const remainder = input.slice(startIdx);\n    const length = input.length;\n    idx++;\n    while (idx < length) {\n      const closeIndex = input.indexOf(close, idx);\n      if (!closeIndex) {\n        idx = length;\n        break;\n      }\n      // escaped close \"\n      if (input[closeIndex - 1] === \"\\\\\") {\n        idx = closeIndex + 1;\n        continue;\n      }\n      idx = closeIndex;\n      break;\n    }\n    if (idx >= length && input[idx] !== close) {\n      throw new Error('missing closing \"');\n    }\n    const value = remainder.substring(trimWrap ? 1 : 0, idx - startIdx + (trimWrap ? 0 : 1));\n    idx++;\n    return [value, idx];\n  }\n}\n","/** @typedef {import('./utils').astNode} astNode */\n/** @typedef {import('./utils').bbscriptFunc} bbscriptFunc */\n/** @typedef {import('./utils').bbscriptFuncMap} bbscriptFuncMap */\n/** @typedef {import('./processor').bbscriptOptions} bbscriptOptions */\nimport $ from \"jquery\";\nimport { bbscriptParamTypes, getStringVal, isAstNode } from \"./utils\";\nimport { ConsoleLogger } from \"../logger\";\n\n/**\n * Conditional if then else\n * @type {bbscriptFunc}\n */\nexport const conditional = {\n  params: [\n    { types: [bbscriptParamTypes.Function] },\n    { types: [bbscriptParamTypes.Function] },\n    { types: [bbscriptParamTypes.Function], default: null },\n  ],\n  func: (options, lhs, rhs, elseBlock) => {\n    const result = options.processor.exec(lhs, options);\n    if (result) {\n      return options.processor.exec(rhs, options);\n    } else if (elseBlock) {\n      return options.processor.exec(elseBlock, options);\n    }\n  },\n};\n/**\n * force stop\n * @type {bbscriptFunc}\n */\nexport const stop = {\n  params: [],\n  func: () => {\n    return { msg: \"stop\" };\n  },\n};\n/**\n * Get the Elements wrapped in JQuery for quick JQuery functionality\n * @param {any} el target input string selector\n * @param {bbscriptOptions} options\n * @returns {any}\n */\nconst getJQueryEl = (el, options) => {\n  if (el) {\n    el = \".\" + getStringVal(el, options).trim() + \"__\" + options.callerId;\n  } else {\n    el = $(options.target);\n  }\n  return $(el);\n};\nexport const addClass = {\n  params: [\n    { types: [bbscriptParamTypes.Identifier] },\n    { types: [bbscriptParamTypes.Identifier], default: null },\n  ],\n  func: (options, newClass, target = \"\") => {\n    newClass = getStringVal(newClass, options) || \"\";\n    newClass &&= newClass + \"__\" + options.callerId;\n    getJQueryEl(target, options).addClass(newClass);\n  },\n};\nexport const removeClass = {\n  params: [\n    { types: [bbscriptParamTypes.Identifier] },\n    { types: [bbscriptParamTypes.Identifier], default: null },\n  ],\n  func: (options, oldClass, target = \"\") => {\n    oldClass = getStringVal(oldClass, options) || \"\";\n    oldClass &&= oldClass + \"__\" + options.callerId;\n    getJQueryEl(target, options).removeClass(oldClass);\n  },\n};\nexport const fadeIn = {\n  params: [\n    { types: [bbscriptParamTypes.Int], default: 1000 },\n    { types: [bbscriptParamTypes.Identifier], default: null },\n  ],\n  func: (options, time = 1000, target) => {\n    getJQueryEl(target, options).fadeIn(time);\n  },\n};\nexport const fadeOut = {\n  params: [\n    { types: [bbscriptParamTypes.Int], default: 1000 },\n    { types: [bbscriptParamTypes.Identifier], default: null },\n  ],\n  func: (options, time = 1000, target) => {\n    getJQueryEl(target, options).fadeOut(time);\n  },\n};\nexport const fadeToggle = {\n  params: [\n    { types: [bbscriptParamTypes.Int], default: 1000 },\n    { types: [bbscriptParamTypes.Identifier], default: null },\n  ],\n  func: (options, time = 1000, target) => {\n    getJQueryEl(target, options).fadeToggle(time);\n  },\n};\nexport const hide = {\n  params: [{ types: [bbscriptParamTypes.Identifier], default: null }],\n  func: (options, target) => {\n    getJQueryEl(target, options).hide();\n  },\n};\nexport const show = {\n  params: [{ types: [bbscriptParamTypes.Identifier], default: null }],\n  func: (options, target) => {\n    getJQueryEl(target, options).show();\n  },\n};\nexport const getText = {\n  params: [{ types: [bbscriptParamTypes.Identifier], default: null }],\n  func: (options, target) => {\n    return getJQueryEl(target, options).text();\n  },\n};\nexport const setText = {\n  params: [\n    {\n      types: [\n        bbscriptParamTypes.String,\n        bbscriptParamTypes.Function,\n        bbscriptParamTypes.Identifier,\n      ],\n    },\n    { types: [bbscriptParamTypes.Identifier], default: null },\n  ],\n  func: (options, input, target) => {\n    if (isAstNode(input)) {\n      input = options.processor.exec(input, options);\n    } else {\n      input = getStringVal(input, options);\n    }\n    getJQueryEl(target, options).text(input);\n  },\n};\nexport const slideDown = {\n  params: [\n    { types: [bbscriptParamTypes.Int], default: 1000 },\n    { types: [bbscriptParamTypes.Identifier], default: null },\n  ],\n  func: (options, time = 1000, target) => {\n    getJQueryEl(target, options).slideDown(time);\n  },\n};\nexport const slideUp = {\n  params: [\n    { types: [bbscriptParamTypes.Int], default: 1000 },\n    { types: [bbscriptParamTypes.Identifier], default: null },\n  ],\n  func: (options, time = 1000, target) => {\n    getJQueryEl(target, options).slideUp(time);\n  },\n};\nexport const slideToggle = {\n  params: [\n    { types: [bbscriptParamTypes.Int], default: 1000 },\n    { types: [bbscriptParamTypes.Identifier], default: null },\n  ],\n  func: (options, time = 1000, target) => {\n    getJQueryEl(target, options).slideToggle(time);\n  },\n};\nconst params = [\n  {\n    types: [\n      bbscriptParamTypes.String,\n      bbscriptParamTypes.Function,\n      bbscriptParamTypes.Int,\n      bbscriptParamTypes.Identifier,\n    ],\n  },\n  {\n    types: [\n      bbscriptParamTypes.String,\n      bbscriptParamTypes.Function,\n      bbscriptParamTypes.Int,\n      bbscriptParamTypes.Identifier,\n    ],\n  },\n];\n/**\n * Common evaluate method to process left and right arguments first if they are nested\n * @param {bbscriptOptions} options\n * @param {unknown} lhs\n * @param {unknown} rhs\n * @returns {any[]}\n */\nconst evaluate = (options, lhs, rhs) => {\n  let leftResult;\n  let rightResult;\n  if (isAstNode(lhs)) {\n    leftResult = options.processor.exec(lhs, options);\n  } else {\n    leftResult = getStringVal(lhs, options);\n  }\n  if (isAstNode(rhs)) {\n    rightResult = options.processor.exec(rhs, options);\n  } else {\n    rightResult = getStringVal(rhs, options);\n  }\n  return [leftResult, rightResult];\n};\n/**\n * is equal to\n * @type {bbscriptFunc}\n */\nexport const eq = {\n  params,\n  func: (options, lhs, rhs) => {\n    const [leftResult, rightResult] = evaluate(options, lhs, rhs);\n    // eslint-disable-next-line eqeqeq\n    return leftResult == rightResult;\n  },\n};\n/**\n * is greater than\n * @type {bbscriptFunc}\n */\nexport const ge = {\n  params,\n  func: (options, lhs, rhs) => {\n    const [leftResult, rightResult] = evaluate(options, lhs, rhs);\n    return leftResult > rightResult;\n  },\n};\n/**\n * is greater than or equal to\n * @type {bbscriptFunc}\n */\nexport const geq = {\n  params,\n  func: (options, lhs, rhs) => {\n    const [leftResult, rightResult] = evaluate(options, lhs, rhs);\n    return leftResult >= rightResult;\n  },\n};\n/**\n * is less than\n * @type {bbscriptFunc}\n */\nexport const le = {\n  params,\n  func: (options, lhs, rhs) => {\n    const [leftResult, rightResult] = evaluate(options, lhs, rhs);\n    return leftResult < rightResult;\n  },\n};\n/**\n * is less than or equal to\n * @type {bbscriptFunc}\n */\nexport const leq = {\n  params,\n  func: (options, lhs, rhs) => {\n    const [leftResult, rightResult] = evaluate(options, lhs, rhs);\n    return leftResult >= rightResult;\n  },\n};\nexport const random = {\n  params: [{ types: [bbscriptParamTypes.Int] }, { types: [bbscriptParamTypes.Int] }],\n  func: (options, min, max) => {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  },\n};\nexport const print = {\n  params: [{ types: [bbscriptParamTypes.String, bbscriptParamTypes.Identifier] }],\n  func: (options, args) => {\n    ConsoleLogger.log(getStringVal(args, options));\n  },\n};\n/**\n * Set variable\n * @type {bbscriptFunc}\n */\nexport const set = {\n  params: [\n    { types: [bbscriptParamTypes.Identifier] },\n    { types: [bbscriptParamTypes.Int, bbscriptParamTypes.String, bbscriptParamTypes.Function] },\n  ],\n  func: (options, id, value) => {\n    if (isAstNode(value)) {\n      value = options.processor.exec(value, options);\n    } else {\n      value = getStringVal(value, options);\n    }\n    const callerId = options.callerId || \"\";\n    if (!(callerId in options.data)) {\n      options.data[callerId] = {};\n    }\n    options.data[callerId][id] = value;\n  },\n};\nexport const add = {\n  params: [\n    {\n      types: [\n        bbscriptParamTypes.Int,\n        bbscriptParamTypes.String,\n        bbscriptParamTypes.Identifier,\n        bbscriptParamTypes.Function,\n      ],\n    },\n    {\n      types: [\n        bbscriptParamTypes.Int,\n        bbscriptParamTypes.String,\n        bbscriptParamTypes.Identifier,\n        bbscriptParamTypes.Function,\n      ],\n    },\n  ],\n  func: (options, a, b) => {\n    if (isAstNode(a)) {\n      a = options.processor.exec(a, options);\n    } else {\n      a = getStringVal(a, options);\n    }\n    if (isAstNode(b)) {\n      b = options.processor.exec(b, options);\n    } else {\n      b = getStringVal(b, options);\n    }\n    return a + b;\n  },\n};\nexport const dec = {\n  params: [\n    { types: [bbscriptParamTypes.Identifier] },\n    { types: [bbscriptParamTypes.Int], default: 1 },\n  ],\n  func: (options, id, amount = 1) => {\n    try {\n      const callerId = options.callerId || \"\";\n      if (!(callerId in options.data)) {\n        options.data[callerId] = {};\n      }\n      options.data[callerId][id] -= amount;\n    } catch (e) {\n      ConsoleLogger.warn(`${id} is not a number`, e);\n    }\n  },\n};\n\nexport const inc = {\n  params: [\n    { types: [bbscriptParamTypes.Identifier] },\n    { types: [bbscriptParamTypes.Int], default: 1 },\n  ],\n  func: (options, id, amount = 1) => {\n    try {\n      const callerId = options.callerId || \"\";\n      if (!(callerId in options.data)) {\n        options.data[callerId] = {};\n      }\n      options.data[callerId][id] += amount;\n    } catch (e) {\n      ConsoleLogger.warn(`${id} is not a number`, e);\n    }\n  },\n};\n\n/**\n * Map between bbscript function name and logic.\n * keys must be all lowercase. Parser will apply lowercase to user input,\n * so is case-insensitive.\n * @type {bbscriptFuncMap}\n */\nexport const bbscriptFunctions = {\n  print,\n  eq,\n  ge,\n  geq,\n  le,\n  leq,\n  if: conditional,\n  stop,\n  set,\n  dec,\n  inc,\n  addclass: addClass,\n  removeclass: removeClass,\n  fadein: fadeIn,\n  fadeout: fadeOut,\n  fadetoggle: fadeToggle,\n  hide,\n  show,\n  gettext: getText,\n  settext: setText,\n  slidedown: slideDown,\n  slideup: slideUp,\n  slidetoggle: slideToggle,\n  random,\n  add,\n};\n","/** @typedef {import('./processor').BBScriptOptions} BBScriptOptions */\n/** @typedef {import('./utils').BBScriptReturnTypes} BBScriptReturnTypes */\nimport { ConsoleLogger } from \"../logger\";\n\nexport class ASTNode {\n  /** @type {number} */\n  _startIdx;\n  /** @type {number} */\n  _endIdx;\n\n  /**\n   * @param {number} startIdx\n   * @param {number} endIdx\n   */\n  constructor(startIdx, endIdx) {\n    this._startIdx = startIdx;\n    this._endIdx = endIdx;\n  }\n  /**\n   * @public\n   * @returns {number}\n   */\n  get startIdx() {\n    return this._startIdx;\n  }\n  /**\n   * @public\n   * @returns {number}\n   */\n  get endIdx() {\n    return this._endIdx;\n  }\n  /**\n   * returns information about the text of the node in the original script\n   * @public\n   * @param {string} text input string\n   * @returns {{ line: number; column: number; text: string; }}\n   */\n  findInText(text) {\n    let line = 1;\n    let column = 1;\n    for (let i = 0; i < text.length; i++) {\n      if (i === this.startIdx) {\n        break;\n      }\n      if (text[i] === \"\\n\") {\n        line++;\n        column = 0;\n      }\n      column++;\n    }\n    return {\n      line,\n      column,\n      text: text.substring(this.startIdx, this.endIdx),\n    };\n  }\n}\n\n/** @extends ASTNode */\nexport class ASTIdentifier extends ASTNode {\n  /** @type {string} */\n  _name;\n\n  /**\n   * @param {number} startIdx\n   * @param {number} endIdx\n   * @param {string} name\n   */\n  constructor(startIdx, endIdx, name) {\n    super(startIdx, endIdx);\n    this._name = name;\n  }\n  /**\n   * @public\n   * @returns {string}\n   */\n  get name() {\n    return this._name;\n  }\n  /**\n   * @public\n   * @param {BBScriptOptions} options\n   * @returns {any}\n   */\n  resolveValue(options) {\n    if (\n      options.callerId &&\n      options.data[options.callerId] &&\n      options.data[options.callerId][this.name] !== undefined\n    ) {\n      return options.data[options.callerId][this.name];\n    } else {\n      return this.name;\n    }\n  }\n}\n\n/** @extends ASTNode */\nexport class ASTFunction extends ASTNode {\n  /** @type {ASTIdentifier} */\n  _identifier;\n  /** @type {ASTNode[]} */\n  _params;\n\n  /**\n   * @param {number} startIdx\n   * @param {number} endIdx\n   * @param {ASTIdentifier} name\n   * @param {ASTNode[]} params\n   */\n  constructor(startIdx, endIdx, name, params) {\n    super(startIdx, endIdx);\n    this._identifier = name;\n    this._params = params;\n  }\n  /**\n   * @public\n   * @returns {ASTIdentifier}\n   */\n  get identifier() {\n    return this._identifier;\n  }\n  /**\n   * @public\n   * @returns {ASTNode[]}\n   */\n  get params() {\n    return this._params;\n  }\n  /**\n   * Processes and executes a single node\n   * @public\n   * @param {BBScriptOptions} options bbscript options\n   * @returns {BBScriptReturnTypes} returns value if applicable\n   */\n  resolveValue(options) {\n    const functions = options.processor.functions;\n    const callable = functions[this.identifier.name];\n    if (callable) {\n      const args = this.params;\n      try {\n        return callable(options, ...args);\n      } catch (error) {\n        ConsoleLogger.warn(\"BBScript Error\", error, this, options);\n      }\n    }\n    ConsoleLogger.info(\"invalid command\", this, options);\n  }\n}\n\n/** @extends ASTNode */\nexport class ASTQuotedString extends ASTNode {\n  /** @type {string} */\n  _string;\n\n  /**\n   * @param {number} startIdx\n   * @param {number} endIdx\n   * @param {string} input\n   */\n  constructor(startIdx, endIdx, input) {\n    super(startIdx, endIdx);\n    this._string = input;\n  }\n  /**\n   * @public\n   * @returns {string}\n   */\n  get string() {\n    return this._string;\n  }\n  /**\n   * @public\n   * @returns {string}\n   */\n  resolveValue(options) {\n    if (this.string.match(/\\$\\{\\w+\\}/)) {\n      // string interpolation. carryover from bbscript1\n      let str = this.string;\n      const matches = str.matchAll(/\\$\\{(\\w+)\\}/g);\n      for (const match of matches) {\n        const presumedValue = options.data?.[options.callerId]?.[\"_\" + match[1] + \"_\"] || match[0];\n        str = str.replace(match[0], presumedValue);\n      }\n      return str;\n    }\n    return this.string;\n  }\n}\n\n/** @extends ASTNode */\nexport class ASTList extends ASTNode {\n  /** @type {ASTNode[]} */\n  _items;\n  /**\n   * @param {number} startIdx\n   * @param {number} endIdx\n   * @param {ASTNode[]} elements\n   */\n  constructor(startIdx, endIdx, elements) {\n    super(startIdx, endIdx);\n    this._items = elements;\n  }\n  /**\n   * @public\n   * @returns {ASTNode[]}\n   */\n  get items() {\n    return this._items;\n  }\n  /**\n   * @public\n   * @param {BBScriptOptions} options\n   * @returns {(string | number | boolean)[]}\n   */\n  resolveValue(options) {\n    return this.items.map((i) => i.resolveValue(options));\n  }\n}\n\n/** @extends ASTNode */\nexport class ASTNumberLiteral extends ASTNode {\n  /** @type {string} */\n  _value;\n\n  /**\n   * @param {number} startIdx\n   * @param {number} endIdx\n   * @param {string} value\n   */\n  constructor(startIdx, endIdx, value) {\n    super(startIdx, endIdx);\n    this._value = value;\n  }\n  /**\n   * @public\n   * @returns {string}\n   */\n  get value() {\n    return this._value;\n  }\n  /**\n   * @public\n   * @returns {number}\n   */\n  resolveValue() {\n    return +this.value;\n  }\n}\n","/** @typedef {import('./AST').ASTNode} ASTNode */\n/** @extends Error */\nexport class ASTError extends Error {\n  /** @type {ASTNode | null} */\n  node;\n\n  /**\n   * @param {ASTNode | null} node\n   * @param {string} message\n   */\n  constructor(node, message) {\n    super(message);\n    this.name = \"ASTError\";\n    this.node = node;\n  }\n  /**\n   * @public\n   * @param {string} text\n   * @returns {string}\n   */\n  format(text) {\n    if (this.node !== null) {\n      const details = this.node.findInText(text);\n      this.message += `: ${details.text} (line ${details.line}, column ${details.column})`;\n    }\n    return this.message;\n  }\n}\n","/** @typedef {import('./AST').ASTNode} ASTNode */\nimport { ASTFunction, ASTIdentifier, ASTList, ASTNumberLiteral, ASTQuotedString } from \"./AST\";\nimport { ASTError } from \"./ASTError\";\n\nexport class BBScriptParser {\n  /** @type {ASTNode[]} */\n  ast = [];\n  /** @type {string} */\n  text = \"\";\n  /** @type {number} */\n  length = 0; // separate value for better dev\n  /** @type {ASTError[]} */\n  errors = [];\n  /** @type {number} */\n  pos = 0;\n\n  /**\n   * Parse input string into AST tree for later processing\n   * @param {string} input string to parse\n   * @returns {{ ast: ASTNode[]; formattedErrors: string[]; }} AST Tree to be processed in BBScript 2 syntax\n   */\n  parse(input) {\n    this.text = input;\n    this.length = this.text.length;\n    let fatalError;\n    try {\n      this.buildAst();\n    } catch (e) {\n      fatalError = new ASTError(null, e?.message);\n    }\n    if (fatalError) {\n      this.errors.push(fatalError);\n    }\n    const formattedErrors = this.errors.map((e) => e.format(this.text));\n    return {\n      ast: this.ast,\n      formattedErrors,\n    };\n  }\n  /**\n   * Builds an AST\n   * @private\n   * @returns {ASTNode[]} AST\n   */\n  buildAst() {\n    this.ast = [];\n    this.errors = [];\n    this.pos = 0;\n    let node;\n    while (this.pos < this.length) {\n      // consume whitespace\n      this.consumeWhitespace();\n      if (this.pos >= this.length) {\n        break;\n      }\n      // top-level function\n      if (this.head() === \"(\") {\n        node = this.processFunctionCall();\n      } else {\n        this.errors.push(new ASTError(null, \"Expecting function call, found \" + this.head()));\n        break;\n      }\n      if (node !== null) {\n        this.ast.push(node);\n      }\n    }\n    return this.ast;\n  }\n  /**\n   * Returns the current character at the cursor\n   * @private\n   * @param {boolean} [throwOnError=true] throw an error if unexpected end of script\n   * @returns {string | null} single character string or `null`\n   */\n  head(throwOnError = true) {\n    if (this.pos < this.length) {\n      return this.text[this.pos];\n    }\n    if (throwOnError) {\n      throw new Error(\"Unexpected end of script\");\n    }\n    return null;\n  }\n  /**\n   * Advance the cursor position if the current cursor points to a whitespace\n   * @private\n   * @returns {void}\n   */\n  consumeWhitespace() {\n    while (this.pos < this.length && this.isWhitespaceChar()) {\n      this.pos++;\n    }\n  }\n  /**\n   * @private\n   * @param {string} [char=this.head() || '']\n   * @returns {boolean}\n   */\n  isWhitespaceChar(char = this.head() || \"\") {\n    return /\\s/.test(char);\n  }\n  /**\n   * Processes the following substring at the cursor position as a function call\n   * @private\n   * @returns {ASTFunction} ASTFunction node\n   */\n  processFunctionCall() {\n    const startIdx = this.pos;\n    // consume starting parentheses\n    this.pos++;\n    const name = this.processIdentifier(\")\", /[^+\\-_*/%<>=!a-zA-Z]/gm);\n    this.consumeWhitespace();\n    const params = [];\n    while (this.head() !== \")\") {\n      this.consumeWhitespace();\n      const char = this.head();\n      switch (char) {\n        case \"(\":\n          params.push(this.processFunctionCall());\n          break;\n        case '\"':\n          params.push(this.processString());\n          break;\n        case \"[\":\n          params.push(this.processList());\n          break;\n        case \")\":\n          // end of function.\n          break;\n        default:\n          if (char === \"-\" || /\\d/.test(char || \"\")) {\n            params.push(this.processNumber());\n          } else {\n            params.push(this.processIdentifier());\n          }\n          break;\n      }\n    }\n    // consume ending parentheses\n    this.pos++;\n    const endIdx = this.pos;\n    return new ASTFunction(startIdx, endIdx, name, params);\n  }\n  /**\n   * Processes a double quoted string starting at the cursor position into an ASTNode\n   * @private\n   * @returns {ASTQuotedString}\n   */\n  processString() {\n    let string = \"\";\n    const startIdx = this.pos;\n    this.pos++;\n    let escaped = false;\n    while (this.head() !== null) {\n      const char = this.head();\n      if (char === '\"') {\n        if (!escaped) {\n          break;\n        }\n        string += char;\n        escaped = false;\n      } else if (char === \"\\\\\") {\n        if (escaped) {\n          string += char;\n        }\n        escaped = !escaped;\n      } else {\n        string += char;\n        escaped = false;\n      }\n      this.pos++;\n    }\n    const endIdx = this.pos;\n    this.pos++;\n    return new ASTQuotedString(startIdx, endIdx, string.replace(\"\\n\", \"\\\\n\"));\n  }\n  /**\n   * Processes a bracketed list starting at the cursor position into an ASTNode\n   *\n   * expects `[item1 item2 item3]`\n   * @private\n   * @returns {ASTList}\n   */\n  processList() {\n    const startIdx = this.pos;\n    this.pos++;\n    const items = [];\n    while (this.head() !== null) {\n      this.consumeWhitespace();\n      const char = this.head();\n      if (char === \"]\") {\n        break;\n      }\n      switch (char) {\n        case \"(\":\n          items.push(this.processFunctionCall());\n          break;\n        case '\"':\n          items.push(this.processString());\n          break;\n        case \"[\":\n          items.push(this.processList());\n          break;\n        default:\n          if (char === \"-\" || /\\d/.test(char || \"\")) {\n            items.push(this.processNumber(\"]\"));\n          } else {\n            items.push(this.processIdentifier(\"]\"));\n          }\n          break;\n      }\n    }\n    // consume closing brace\n    this.pos++;\n    const endIdx = this.pos;\n    return new ASTList(startIdx, endIdx, items);\n  }\n  /**\n   * Processes a number literal starting at the cursor position\n   * @private\n   * @param {string} [end=')'] terminating characters to stop at\n   * @returns {ASTNumberLiteral}\n   */\n  processNumber(end = \")\") {\n    const startIdx = this.pos;\n    if (this.head() === \"-\") {\n      this.pos++;\n    }\n    while (!this.isWhitespaceChar() && this.head() !== end) {\n      this.pos++;\n    }\n    const endIdx = this.pos;\n    const value = this.text.substring(startIdx, endIdx);\n    const numberLiteral = new ASTNumberLiteral(startIdx, endIdx, value);\n    if (isNaN(+value)) {\n      this.errors.push(new ASTError(numberLiteral, \"Invalid number literal\"));\n    }\n    return numberLiteral;\n  }\n  /**\n   * Processes an identifier at the cursor position\n   * @private\n   * @param {string} [end=')'] end character to stop at\n   * @param {RegExp} [invalidChars=/[^_a-zA-Z]/gm] regex to check against\n   * @returns {ASTIdentifier}\n   */\n  processIdentifier(end = \")\", invalidChars = /[^_a-zA-Z]/gm) {\n    const nameStartIdx = this.pos;\n    while (!this.isWhitespaceChar() && this.head() !== end) {\n      this.pos++;\n    }\n    const nameEndIdx = this.pos;\n    const identifier = new ASTIdentifier(\n      nameStartIdx,\n      nameEndIdx,\n      this.text.substring(nameStartIdx, nameEndIdx),\n    );\n    // validate identifier\n    if (invalidChars.test(identifier.name)) {\n      this.errors.push(new ASTError(identifier, \"Invalid function identifier\"));\n    }\n    if (identifier.name.length === 0) {\n      this.errors.push(new ASTError(identifier, \"Missing function identifier\"));\n    }\n    return identifier;\n  }\n}\n","/** @typedef {import('./AST').ASTNode} ASTNode */\n/** @typedef {import('./utils').BBScriptFuncMap} BBScriptFuncMap */\n\n/**\n * @typedef {Object} BBScriptOptions\n * @property {string} callerId\n * @property {string} callerClass\n * @property {any} data\n * @property {BBScriptProcessor} processor\n * @property {Element} target\n */\n\nexport class BBScriptProcessor {\n  /** @type {BBScriptOptions} */\n  options;\n  /** @type {BBScriptFuncMap} */\n  functions;\n\n  /**\n   * @param {BBScriptFuncMap} functions\n   * @param {BBScriptOptions} [defaultOptions={} as BBScriptOptions]\n   */\n  constructor(functions, defaultOptions = {}) {\n    defaultOptions = {\n      ...defaultOptions,\n      processor: this,\n    };\n    this.options = defaultOptions;\n    this.functions = functions;\n  }\n  /**\n   * Processes and executes all commands in node tree\n   * @param {ASTNode[]} nodeTree input node tree, generated by `parse()`\n   * @param {string} callerId\n   * @param {string} callerClass\n   * @param {BBScriptOptions} [options=this.options] options to use\n   * @returns {void}\n   */\n  execAll(nodeTree, callerId, callerClass, options = this.options) {\n    options = {\n      ...this.options,\n      ...options,\n      callerId,\n      callerClass,\n    };\n    for (const node of nodeTree) {\n      node.resolveValue(options);\n    }\n  }\n}\n","/** @typedef {import('./utils').BBScriptFunc} BBScriptFunc */\n/** @typedef {import('./utils').BBScriptFuncMap} BBScriptFuncMap */\n/** @typedef {import('./utils').BBScriptReturnTypes} BBScriptReturnTypes */\n/** @typedef {import('./AST').ASTNode} ASTNode */\n/** @typedef {import('./processor').BBScriptOptions} BBScriptOptions */\nimport $ from \"jquery\";\nimport { ASTError } from \"./ASTError\";\nimport { ASTIdentifier } from \"./AST\";\nimport { ConsoleLogger } from \"../logger\";\n\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} arr\n * @returns {number}\n */\nconst count = (options, arr) => {\n  const arrVal = arr.resolveValue(options);\n  if (Array.isArray(arrVal) || typeof arrVal === \"string\") {\n    return arrVal.length;\n  } else {\n    throw new ASTError(arr, \"Does not resolve to an array or string\");\n  }\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} arr\n * @param {ASTNode} needle\n * @returns {boolean}\n */\nconst contain = (options, arr, needle) => {\n  const arrVal = arr.resolveValue(options);\n  const needleVal = needle.resolveValue(options);\n  if (Array.isArray(arrVal) && needleVal !== undefined) {\n    return arrVal.includes(needleVal);\n  }\n  if (typeof arrVal === \"string\" && needleVal !== undefined) {\n    return arrVal.includes(needleVal);\n  }\n  if (!Array.isArray(arrVal) || typeof arrVal !== \"string\") {\n    throw new ASTError(arr, \"Does not resolve to an array or string\");\n  }\n  return false;\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} arr\n * @param {ASTNode} needle\n * @returns {number}\n */\nconst find = (options, arr, needle) => {\n  const arrVal = arr.resolveValue(options);\n  const needleVal = needle.resolveValue(options);\n  if (Array.isArray(arrVal) && needleVal !== undefined) {\n    return arrVal.indexOf(needleVal);\n  }\n  if (!Array.isArray(arrVal)) {\n    throw new ASTError(arr, \"Does not resolve to an array\");\n  }\n  return -1;\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} arr\n * @param {ASTNode} i\n * @param {ASTNode | undefined} [val]\n * @returns {BBScriptReturnTypes}\n */\nconst index = (options, arr, i, val) => {\n  const arrVal = arr.resolveValue(options);\n  const idx = +i.resolveValue(options);\n  if (!Array.isArray(arrVal)) {\n    throw new ASTError(arr, \"Does not resolve to an array\");\n  }\n  if (val === undefined) {\n    return arrVal[idx];\n  }\n  const newVal = val.resolveValue(options);\n  arrVal[idx] = newVal;\n  return arrVal[idx];\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} arr\n * @param {ASTNode} val\n * @returns {number}\n */\nconst append = (options, arr, val) => {\n  const arrVal = arr.resolveValue(options);\n  const newVal = val.resolveValue(options);\n  if (!Array.isArray(arrVal)) {\n    throw new ASTError(arr, \"Does not resolve to an array\");\n  }\n  // js array is pass by reference, so options.data will be updated if applicable\n  return arrVal.push(newVal);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} arr\n * @param {ASTNode} i\n * @param {ASTNode} val\n * @returns {void}\n */\nconst insert = (options, arr, i, val) => {\n  const arrVal = arr.resolveValue(options);\n  if (!Array.isArray(arrVal)) {\n    throw new ASTError(arr, \"Does not resolve to an array\");\n  }\n  const idx = +i.resolveValue(options);\n  if (typeof idx !== \"number\") {\n    throw new ASTError(i, \"Does not resolve to a number\");\n  }\n  const newVal = val.resolveValue(options);\n  arrVal.splice(Math.floor(idx), 0, newVal);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} arr\n * @returns {BBScriptReturnTypes | undefined}\n */\nconst pop = (options, arr) => {\n  const arrVal = arr.resolveValue(options);\n  if (!Array.isArray(arrVal)) {\n    throw new ASTError(arr, \"Does not resolve to an array\");\n  }\n  return arrVal.pop();\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} arr\n * @param {ASTNode} i\n * @returns {BBScriptReturnTypes}\n */\nconst remove = (options, arr, i) => {\n  const arrVal = arr.resolveValue(options);\n  if (!Array.isArray(arrVal)) {\n    throw new ASTError(arr, \"Does not resolve to an array\");\n  }\n  const idx = +i.resolveValue(options);\n  return arrVal.splice(idx, 1)[0];\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} arr\n * @returns {BBScriptReturnTypes[]}\n */\nconst reverse = (options, arr) => {\n  const arrVal = arr.resolveValue(options);\n  if (!Array.isArray(arrVal)) {\n    throw new ASTError(arr, \"Does not resolve to an array\");\n  }\n  return arrVal.reverse();\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} arr\n * @param {ASTNode | undefined} [sep]\n * @returns {string}\n */\nconst join = (options, arr, sep) => {\n  const arrVal = arr.resolveValue(options);\n  let sepVal = \"\";\n  if (!Array.isArray(arrVal)) {\n    throw new ASTError(arr, \"Does not resolve to an array\");\n  }\n  if (sep !== undefined) {\n    sepVal = String(sep.resolveValue(options));\n  }\n  return arrVal.join(sepVal);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} arr\n * @returns {BBScriptReturnTypes[]}\n */\nconst shuffle = (options, arr) => {\n  const arrVal = arr.resolveValue(options);\n  if (!Array.isArray(arrVal)) {\n    throw new ASTError(arr, \"Does not resolve to an array\");\n  }\n  for (let i = arrVal.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arrVal[i], arrVal[j]] = [arrVal[j], arrVal[i]];\n  }\n  return arrVal;\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} arr\n * @param {ASTNode} start\n * @param {ASTNode} end\n * @returns {string | BBScriptReturnTypes[]}\n */\nconst slice = (options, arr, start, end) => {\n  const val = arr.resolveValue(options);\n  if (!Array.isArray(val) && typeof val !== \"string\") {\n    throw new ASTError(arr, \"Does not resolve to an array or string\");\n  }\n  const startVal = +start.resolveValue(options);\n  const endVal = +end.resolveValue(options);\n  return val.slice(startVal, endVal);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} arr\n * @param {ASTNode} func\n * @param {ASTNode | undefined} [token]\n * @returns {void}\n */\nconst each = (options, arr, func, token) => {\n  const arrVal = arr.resolveValue(options);\n  if (!Array.isArray(arrVal)) {\n    throw new ASTError(arr, \"Does not resolve to an array\");\n  }\n  const tokenVar = token !== undefined ? String(token.resolveValue(options)) : \"_\";\n  // eslint-disable-next-line eqeqeq\n  if (options.data[options.callerId] == undefined) {\n    options.data[options.callerId] = {};\n  }\n  for (const e of arrVal) {\n    options.data[options.callerId][tokenVar] = e;\n    func.resolveValue(options);\n  }\n  delete options.data[options.callerId][tokenVar];\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode | undefined} [target]\n */\nconst getJQueryEl = (options, target) => {\n  if (target !== undefined) {\n    const search = \".\" + String(target.resolveValue(options)).trim() + \"__\" + options.callerId;\n    return $(search);\n  } else {\n    return $(options.target);\n  }\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} newClass\n * @param {ASTNode | undefined} [target]\n * @returns {void}\n */\nconst addClass = (options, newClass, target) => {\n  let className = String(newClass.resolveValue(options));\n  className &&= className + \"__\" + options.callerId;\n  const targetEl = getJQueryEl(options, target);\n  targetEl.addClass(className);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} oldClass\n * @param {ASTNode | undefined} [target]\n * @returns {void}\n */\nconst removeClass = (options, oldClass, target) => {\n  let className = String(oldClass.resolveValue(options));\n  className &&= className + \"__\" + options.callerId;\n  const targetEl = getJQueryEl(options, target);\n  targetEl.removeClass(className);\n};\n/**\n * Scroll the target element into view\n * @param {BBScriptOptions} options\n * @param {ASTNode | undefined} target\n */\nconst scrollIntoView = (options, target) => {\n  const targetEl = getJQueryEl(options, target);\n  targetEl[0].scrollIntoView();\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode | undefined} [duration]\n * @param {ASTNode | undefined} [target]\n * @returns {void}\n */\nconst fadeIn = (options, duration, target) => {\n  const targetEl = getJQueryEl(options, target);\n  if (duration !== undefined) {\n    const time = +duration.resolveValue(options);\n    targetEl.fadeIn(time || 1000);\n  } else {\n    targetEl.fadeIn(1000);\n  }\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode | undefined} [duration]\n * @param {ASTNode | undefined} [target]\n * @returns {void}\n */\nconst fadeOut = (options, duration, target) => {\n  const targetEl = getJQueryEl(options, target);\n  if (duration !== undefined) {\n    const time = +duration.resolveValue(options);\n    targetEl.fadeOut(time || 1000);\n  } else {\n    targetEl.fadeOut(1000);\n  }\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode | undefined} [duration]\n * @param {ASTNode | undefined} [target]\n * @returns {void}\n */\nconst fadeToggle = (options, duration, target) => {\n  const targetEl = getJQueryEl(options, target);\n  if (duration !== undefined) {\n    const time = +duration.resolveValue(options);\n    targetEl.fadeToggle(time || 1000);\n  } else {\n    targetEl.fadeToggle(1000);\n  }\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode | undefined} [target]\n * @returns {void}\n */\nconst hide = (options, target) => {\n  const targetEl = getJQueryEl(options, target);\n  targetEl.hide();\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode | undefined} [target]\n * @returns {void}\n */\nconst show = (options, target) => {\n  const targetEl = getJQueryEl(options, target);\n  targetEl.show();\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode | undefined} [target]\n * @returns {any}\n */\nconst getText = (options, target) => {\n  const targetEl = getJQueryEl(options, target);\n  return targetEl.text();\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} text\n * @param {ASTNode | undefined} [target]\n * @returns {void}\n */\nconst setText = (options, text, target) => {\n  const targetEl = getJQueryEl(options, target);\n  const textVal = text.resolveValue(options);\n  targetEl.text(textVal);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode | undefined} [duration]\n * @param {ASTNode | undefined} [target]\n * @returns {void}\n */\nconst slideDown = (options, duration, target) => {\n  const targetEl = getJQueryEl(options, target);\n  if (duration !== undefined) {\n    const time = +duration.resolveValue(options);\n    targetEl.slideDown(time || 1000);\n  } else {\n    targetEl.slideDown(1000);\n  }\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode | undefined} [duration]\n * @param {ASTNode | undefined} [target]\n * @returns {void}\n */\nconst slideUp = (options, duration, target) => {\n  const targetEl = getJQueryEl(options, target);\n  if (duration !== undefined) {\n    const time = +duration.resolveValue(options);\n    targetEl.slideUp(time || 1000);\n  } else {\n    targetEl.slideUp(1000);\n  }\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode | undefined} [duration]\n * @param {ASTNode | undefined} [target]\n * @returns {void}\n */\nconst slideToggle = (options, duration, target) => {\n  const targetEl = getJQueryEl(options, target);\n  if (duration !== undefined) {\n    const time = +duration.resolveValue(options);\n    targetEl.slideToggle(time || 1000);\n  } else {\n    targetEl.slideToggle(1000);\n  }\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} classes\n * @param {ASTNode | undefined} [target]\n * @returns {void}\n */\nconst addDiv = (options, classes, target) => {\n  const targetEl = getJQueryEl(options, target);\n  let classList = \"\";\n  const classVal = classes.resolveValue(options);\n  if (Array.isArray(classVal)) {\n    classList = classVal.map((c) => c + \"__\" + options.callerId).join(\" \");\n  } else {\n    classList = classVal + \"__\" + options.callerId;\n  }\n  targetEl.append(`<div class=\"${classList}\"></div>`);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} classes\n * @param {ASTNode | undefined} [target]\n * @returns {void}\n */\nconst removeDiv = (options, classes, target) => {\n  const targetEl = getJQueryEl(options, target);\n  let classList = \"\";\n  const classVal = classes.resolveValue(options);\n  if (Array.isArray(classVal)) {\n    classList = \".\" + classVal.map((c) => c + \"__\" + options.callerId).join(\".\");\n  } else {\n    classList = \".\" + classVal + \"__\" + options.callerId;\n  }\n  targetEl.remove(classList);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {...ASTNode} [params]\n * @returns {boolean}\n */\nconst and = (options, ...params) => {\n  return params.every((a) => !!a.resolveValue(options)); // allows for quick fallout if falsy\n};\n/**\n * @param {BBScriptOptions} options\n * @param {...ASTNode} [params]\n * @returns {boolean}\n */\nconst or = (options, ...params) => {\n  return params.some((a) => !!a.resolveValue(options)); // allows for quick fallout if truthy\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} lhs\n * @param {ASTNode} rhs\n * @returns {boolean}\n */\nconst equal = (options, lhs, rhs) => {\n  // eslint-disable-next-line eqeqeq\n  return lhs.resolveValue(options) == rhs.resolveValue(options);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} lhs\n * @param {ASTNode} rhs\n * @returns {boolean}\n */\nconst notEqual = (options, lhs, rhs) => {\n  // eslint-disable-next-line eqeqeq\n  return lhs.resolveValue(options) != rhs.resolveValue(options);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} lhs\n * @param {ASTNode} rhs\n * @returns {boolean}\n */\nconst greaterThan = (options, lhs, rhs) => {\n  return lhs.resolveValue(options) > rhs.resolveValue(options);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} lhs\n * @param {ASTNode} rhs\n * @returns {boolean}\n */\nconst greaterOrEqual = (options, lhs, rhs) => {\n  return lhs.resolveValue(options) >= rhs.resolveValue(options);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} lhs\n * @param {ASTNode} rhs\n * @returns {boolean}\n */\nconst lessThan = (options, lhs, rhs) => {\n  return lhs.resolveValue(options) < rhs.resolveValue(options);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} lhs\n * @param {ASTNode} rhs\n * @returns {boolean}\n */\nconst lessOrEqual = (options, lhs, rhs) => {\n  return lhs.resolveValue(options) <= rhs.resolveValue(options);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} test\n * @param {ASTNode} caseTrue\n * @param {ASTNode | undefined} [caseFalse]\n * @returns {BBScriptReturnTypes}\n */\nconst conditional = (options, test, caseTrue, caseFalse) => {\n  const result = test.resolveValue(options);\n  if (result) {\n    return caseTrue.resolveValue(options);\n  } else if (caseFalse !== undefined) {\n    return caseFalse.resolveValue(options);\n  }\n};\n/**\n * @param {BBScriptOptions} options\n * @param {...ASTNode} [exec]\n * @returns {BBScriptReturnTypes}\n */\nconst group = (options, ...exec) => {\n  const values = exec.map((a) => a.resolveValue(options));\n  return values[values.length - 1];\n};\n/**\n * @returns {never}\n */\nconst stop = () => {\n  throw new Error(\"BBScript Stop Command\"); // throw an error for easy exit and less try-catching\n};\n/**\n * @returns {number}\n */\nconst random = () => {\n  return Math.random();\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} min\n * @param {ASTNode} max\n * @returns {number}\n */\nconst randomInt = (options, min, max) => {\n  const minVal = +min.resolveValue(options);\n  const maxVal = +max.resolveValue(options);\n  return Math.floor(Math.random() * (maxVal - minVal + 1) + minVal);\n};\n/**\n * @returns {number}\n */\nconst time = () => {\n  return new Date().getTime();\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} secs\n * @param {ASTNode} func\n * @returns {number}\n */\nconst timeoutFunc = (options, secs, func) => {\n  const secsVal = secs.resolveValue(options);\n  if (typeof secsVal !== \"number\") {\n    throw new ASTError(secs, \"Does not resolve to a number\");\n  }\n  return setTimeout(\n    () => {\n      func.resolveValue(options);\n    },\n    Math.round(secsVal * 1000),\n  );\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} id\n * @returns {void}\n */\nconst clearTimeoutFunc = (options, id) => {\n  const handle = +id.resolveValue(options);\n  clearTimeout(handle);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} secs\n * @param {ASTNode} func\n * @returns {number}\n */\nconst intervalFunc = (options, secs, func) => {\n  const secsVal = secs.resolveValue(options);\n  if (typeof secsVal !== \"number\") {\n    throw new ASTError(secs, \"Does not resolve to a number\");\n  }\n  return setInterval(() => func.resolveValue(options), Math.round(secsVal * 1000));\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} id\n * @returns {void}\n */\nconst clearIntervalFunc = (options, id) => {\n  const handle = +id.resolveValue(options);\n  clearInterval(handle);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {...ASTNode} [nodes]\n * @returns {void}\n */\nconst print = (options, ...nodes) => {\n  const values = nodes.map((n) => n.resolveValue(options));\n  ConsoleLogger.log(...values);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} str\n * @param {ASTNode | undefined} [sep]\n * @returns {string[]}\n */\nconst split = (options, str, sep) => {\n  const strVal = String(str.resolveValue(options));\n  let sepVal = \"\";\n  if (sep !== undefined) {\n    const res = sep.resolveValue(options);\n    if (typeof res === \"string\") {\n      sepVal = res;\n    }\n  }\n  return strVal.split(sepVal);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} str\n * @returns {string}\n */\nconst lower = (options, str) => {\n  const strVal = String(str.resolveValue(options));\n  return strVal.toLowerCase();\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} str\n * @returns {string}\n */\nconst upper = (options, str) => {\n  const strVal = String(str.resolveValue(options));\n  return strVal.toUpperCase();\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} str\n * @returns {string}\n */\nconst trim = (options, str) => {\n  const strVal = String(str.resolveValue(options));\n  return strVal.trim();\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} str\n * @param {ASTNode} needle\n * @param {ASTNode} replacement\n * @returns {string}\n */\nconst replace = (options, str, needle, replacement) => {\n  const strVal = String(str.resolveValue(options));\n  return strVal.replaceAll(needle.resolveValue(options), replacement.resolveValue(options));\n};\n/**\n * create/assign to data variable\n * @param {BBScriptOptions} options\n * @param {ASTNode} variable\n * @param {ASTNode} input\n * @returns {void}\n */\nconst assign = (options, variable, input) => {\n  const value = input.resolveValue(options);\n  let varName;\n  if (variable instanceof ASTIdentifier) {\n    varName = variable.name;\n    // eslint-disable-next-line eqeqeq\n    if (options.data[options.callerId] == undefined) {\n      options.data[options.callerId] = {};\n    }\n    options.data[options.callerId][varName] = value;\n    return;\n  }\n  throw new ASTError(variable, \"Cannot assign to non identifier\");\n};\n/**\n * JS loosy add for strings or nums\n * @param {BBScriptOptions} options\n * @param {...ASTNode} [params]\n * @returns {string | number}\n */\nconst add = (options, ...params) => {\n  const addElems = params.map((p) => p.resolveValue(options));\n  return addElems.reduce((a, b) => a + b);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode[]} param\n * @returns {number[]}\n */\nconst resolveToNums = (options, param) => {\n  return param.map((p) => {\n    const v = p.resolveValue(options);\n    if (typeof v !== \"number\") {\n      throw new ASTError(p, \"Does not resolve to a number\");\n    }\n    return v;\n  });\n};\n/**\n * @param {BBScriptOptions} options\n * @param {...ASTNode} [params]\n * @returns {number}\n */\nconst subtract = (options, ...params) => {\n  const subElems = resolveToNums(options, params);\n  return subElems.reduce((a, b) => a - b);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {...ASTNode} [params]\n * @returns {number}\n */\nconst multiply = (options, ...params) => {\n  const elems = resolveToNums(options, params);\n  return elems.reduce((a, b) => a * b);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {...ASTNode} [params]\n * @returns {number}\n */\nconst divide = (options, ...params) => {\n  const elems = resolveToNums(options, params);\n  return elems.reduce((a, b) => a / b);\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} value\n * @param {ASTNode} base\n * @returns {number}\n */\nconst mod = (options, value, base) => {\n  const [valueNum, baseNum] = resolveToNums(options, [value, base]);\n  return valueNum % baseNum;\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} base\n * @param {ASTNode} expo\n * @returns {number}\n */\nconst exp = (options, base, expo) => {\n  const [expoNum, baseNum] = resolveToNums(options, [expo, base]);\n  return baseNum ** expoNum;\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} variable\n * @returns {void}\n */\nconst decrement = (options, variable) => {\n  if (variable instanceof ASTIdentifier) {\n    const varName = variable.name;\n    if (\n      // eslint-disable-next-line eqeqeq\n      options.data[options.callerId] == undefined ||\n      // eslint-disable-next-line eqeqeq\n      options.data[options.callerId][varName] == undefined\n    ) {\n      throw new ASTError(variable, \"Identifier not set yet\");\n    }\n    if (typeof options.data[options.callerId][varName] !== \"number\") {\n      throw new ASTError(variable, \"Not a number\");\n    }\n    options.data[options.callerId][varName] -= 1;\n    return;\n  }\n  throw new ASTError(variable, \"Not an identifier variable\");\n};\n/**\n * @param {BBScriptOptions} options\n * @param {ASTNode} variable\n * @returns {void}\n */\nconst increment = (options, variable) => {\n  if (variable instanceof ASTIdentifier) {\n    const varName = variable.name;\n    if (\n      // eslint-disable-next-line eqeqeq\n      options.data[options.callerId] == undefined ||\n      // eslint-disable-next-line eqeqeq\n      options.data[options.callerId][varName] == undefined\n    ) {\n      throw new ASTError(variable, \"Identifier not set yet\");\n    }\n    if (typeof options.data[options.callerId][varName] !== \"number\") {\n      throw new ASTError(variable, \"Not a number\");\n    }\n    options.data[options.callerId][varName] += 1;\n    return;\n  }\n  throw new ASTError(variable, \"Not an identifier variable\");\n};\nexport const bbscriptFunctions = {\n  count,\n  contain,\n  find,\n  index,\n  append,\n  insert,\n  pop,\n  remove,\n  reverse,\n  join,\n  shuffle,\n  slice,\n  each,\n  addClass,\n  removeClass,\n  scrollIntoView,\n  fadeIn,\n  fadeOut,\n  fadeToggle,\n  hide,\n  show,\n  getText,\n  setText,\n  slideDown,\n  slideUp,\n  slideToggle,\n  addDiv,\n  removeDiv,\n  and,\n  or,\n  \"==\": equal,\n  \"!=\": notEqual,\n  \">\": greaterThan,\n  \">=\": greaterOrEqual,\n  \"<\": lessThan,\n  \"<=\": lessOrEqual,\n  if: conditional,\n  group,\n  stop,\n  random,\n  randomInt,\n  time,\n  setTimeout: timeoutFunc,\n  clearTimeout: clearTimeoutFunc,\n  setInterval: intervalFunc,\n  clearInterval: clearIntervalFunc,\n  print,\n  split,\n  lower,\n  upper,\n  trim,\n  replace,\n  \"=\": assign,\n  \"+\": add,\n  \"-\": subtract,\n  \"*\": multiply,\n  \"/\": divide,\n  \"%\": mod,\n  \"**\": exp,\n  \"--\": decrement,\n  \"++\": increment,\n};\n","/** @typedef {import('./bbscript1/processor').bbscriptOptions} bbscriptOptions */\n/** @typedef {import('./bbscript1/utils').astNode} astNode */\n/** @typedef {import('./bbscript2/AST').ASTNode} ASTNode */\n/** @typedef {import('./bbscript2/processor').BBScriptOptions} BBScriptOptions */\nimport { initBBScript1 } from \"./bbscript1/bbscript1\";\nimport { initBBScript2 } from \"./bbscript2/bbscript2\";\nconst bbscriptData = {};\nconst bbscriptProcessorV1 = initBBScript1(bbscriptData);\nconst { processor: bbscriptProcessorV2, parser: bbscript2Parser } = initBBScript2(bbscriptData);\n// eslint-disable-next-line no-console\nconsole.info(\"BBCodePlus Addon JS Loaded\");\n\n/**\n * @module bbscriptParser\n */\nexport { bbscriptData, bbscriptProcessorV1, bbscriptProcessorV2, bbscript2Parser };\n","/** @typedef {import('./processor.js').bbscriptOptions} bbscript1Options */\nimport { BBScriptProcessor as BBScript1Processor } from \"./processor.js\";\nimport { bbscriptFunctions } from \"./functions.js\";\n/**\n * @param {any} bbscriptData\n * @returns {BBScript1Processor}\n */\nexport function initBBScript1(bbscriptData) {\n  return new BBScript1Processor(bbscriptFunctions, { data: bbscriptData });\n}\n","/** @typedef {import('./processor').BBScriptOptions} BBScriptOptions */\nimport { BBScriptParser } from \"./parser\";\nimport { BBScriptProcessor as BBScript2Processor } from \"./processor\";\nimport { bbscriptFunctions } from \"./functions\";\n/**\n * @param {any} bbscriptData\n * @returns {{ processor: BBScript2Processor; parser: BBScriptParser; }}\n */\nexport function initBBScript2(bbscriptData) {\n  return {\n    processor: new BBScript2Processor(bbscriptFunctions, { data: bbscriptData }),\n    parser: new BBScriptParser(),\n  };\n}\n"],"names":["bbscriptParamTypes","Object","freeze","Function","Symbol","String","Identifier","Int","isAstNode","input","getOwnPropertyNames","every","v","includes","getStringVal","str","options","match","callerId","data","undefined","matches","matchAll","presumedValue","replace","ConsoleLogger","static","console","log","warn","error","info","debug","BBScriptProcessor$1","functions","constructor","bbscriptFunc","defaultOptions","processor","this","execAll","nodeTree","callerClass","node","res","exec","msg","callable","name","func","args","params","parse","raw","line","split","trim","startsWith","push","process","e","idx","part1","parts","toLowerCase","join","Error","foundFunc","types","validParamType","default","defaultValue","value","length","isString","getEnclosedParameter","childFunc","overallIdx","braceVar","substring","isNaN","parseFloat","close","trimWrap","startIdx","remainder","slice","closeIndex","indexOf","conditional","lhs","rhs","elseBlock","getJQueryEl","el","$","target","addClass","newClass","removeClass","oldClass","fadeIn","time","fadeOut","fadeToggle","hide","show","getText","text","setText","slideDown","slideUp","slideToggle","evaluate","leftResult","rightResult","eq","ge","geq","le","leq","random","min","max","Math","floor","print","set","id","add","a","b","bbscriptFunctions","if","stop","dec","amount","inc","addclass","removeclass","fadein","fadeout","fadetoggle","gettext","settext","slidedown","slideup","slidetoggle","ASTNode","_startIdx","_endIdx","endIdx","findInText","column","i","ASTIdentifier","_name","super","resolveValue","ASTFunction","_identifier","_params","identifier","ASTQuotedString","_string","string","ASTList","_items","elements","items","map","ASTNumberLiteral","_value","ASTError","message","format","details","BBScriptParser","ast","errors","pos","fatalError","buildAst","formattedErrors","consumeWhitespace","head","processFunctionCall","throwOnError","isWhitespaceChar","char","test","processIdentifier","processString","processList","processNumber","escaped","end","numberLiteral","invalidChars","nameStartIdx","nameEndIdx","BBScriptProcessor","search","resolveToNums","param","p","count","arr","arrVal","Array","isArray","contain","needle","needleVal","find","index","val","newVal","append","insert","splice","pop","remove","reverse","sep","sepVal","shuffle","j","start","startVal","endVal","each","token","tokenVar","className","scrollIntoView","duration","targetEl","textVal","addDiv","classes","classList","classVal","c","removeDiv","and","or","some","caseTrue","caseFalse","group","values","randomInt","minVal","maxVal","Date","getTime","setTimeout","secs","secsVal","round","clearTimeout","handle","setInterval","clearInterval","nodes","n","strVal","lower","upper","toUpperCase","replacement","replaceAll","variable","varName","reduce","base","valueNum","baseNum","expo","expoNum","bbscriptData","bbscriptProcessorV1","BBScript1Processor","initBBScript1","bbscriptProcessorV2","parser","bbscript2Parser","BBScript2Processor","initBBScript2"],"mappings":"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"}
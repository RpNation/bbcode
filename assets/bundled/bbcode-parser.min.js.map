{"version":3,"file":"bbcode-parser.min.js","sources":["../../node_modules/@bbob/plugin-helper/es/char.js","../../node_modules/@bbob/plugin-helper/es/helpers.js","../../node_modules/@bbob/plugin-helper/es/TagNode.js","../../node_modules/@bbob/parser/es/Token.js","../../node_modules/@bbob/parser/es/utils.js","../../node_modules/@bbob/parser/es/lexer.js","../../node_modules/@bbob/parser/es/parse.js","../../node_modules/@bbob/core/es/utils.js","../../node_modules/@bbob/core/es/index.js","../../node_modules/@bbob/html/es/index.js","../../bbcode-src/utils/common.js","../../bbcode-src/plugins/lineBreak.js","../../bbcode-src/plugins/preserveWhitespace.js","../../bbcode-src/plugins/removeEmptyLinesInAttr.js","../../node_modules/@bbob/preset/es/preset.js","../../bbcode-src/tags/accordion.js","../../bbcode-src/tags/alignment.js","../../bbcode-src/tags/anchor.js","../../bbcode-src/tags/font.js","../../bbcode-src/tags/heightrestrict.js","../../bbcode-src/tags/mail.js","../../bbcode-src/tags/rowcolumn.js","../../bbcode-src/tags/script.js","../../bbcode-src/tags/size.js","../../bbcode-src/tags/textmessage.js","../../bbcode-src/preset.js","../../bbcode-src/tags/animation.js","../../bbcode-src/tags/background.js","../../bbcode-src/tags/block.js","../../bbcode-src/tags/blockquote.js","../../bbcode-src/tags/border.js","../../bbcode-src/tags/lineBreak.js","../../bbcode-src/tags/centerblock.js","../../bbcode-src/tags/check.js","../../bbcode-src/tags/class.js","../../bbcode-src/tags/code.js","../../bbcode-src/tags/color.js","../../bbcode-src/tags/comment.js","../../bbcode-src/tags/div.js","../../bbcode-src/tags/divide.js","../../bbcode-src/tags/fieldset.js","../../bbcode-src/tags/fontawesome.js","../../bbcode-src/tags/header.js","../../bbcode-src/tags/highlight.js","../../bbcode-src/tags/imagefloat.js","../../bbcode-src/tags/spoiler.js","../../bbcode-src/tags/justify.js","../../bbcode-src/tags/newspaper.js","../../bbcode-src/tags/note.js","../../bbcode-src/tags/ooc.js","../../bbcode-src/tags/pindent.js","../../bbcode-src/tags/plain.js","../../bbcode-src/tags/print.js","../../bbcode-src/tags/progress.js","../../bbcode-src/tags/quote.js","../../bbcode-src/tags/thinprogress.js","../../bbcode-src/tags/scroll.js","../../bbcode-src/tags/side.js","../../bbcode-src/tags/subscript.js","../../bbcode-src/tags/superscript.js","../../bbcode-src/tags/tabs.js","../../bbcode-src/tags/discourse-core-replacement.js","../../bbcode-src/utils/postprocess.js","../../bbcode-src/utils/preprocess.js","../../bbcode-src/index.js","../../node_modules/@bbob/core/es/errors.js"],"sourcesContent":["const N = '\\n';\nconst TAB = '\\t';\nconst F = '\\f';\nconst R = '\\r';\nconst EQ = '=';\nconst QUOTEMARK = '\"';\nconst SPACE = ' ';\nconst OPEN_BRAKET = '[';\nconst CLOSE_BRAKET = ']';\nconst SLASH = '/';\nconst BACKSLASH = '\\\\';\nexport { N, F, R, EQ, TAB, SPACE, SLASH, BACKSLASH, QUOTEMARK, OPEN_BRAKET, CLOSE_BRAKET };\n","import { N } from './char';\nfunction isTagNode(el) {\n    return typeof el === 'object' && el !== null && 'tag' in el;\n}\nfunction isStringNode(el) {\n    return typeof el === 'string';\n}\n// check string is end of line\nfunction isEOL(el) {\n    return el === N;\n}\nfunction keysReduce(obj, reduce, def) {\n    const keys = Object.keys(obj);\n    return keys.reduce((acc, key)=>reduce(acc, key, obj), def);\n}\nfunction getNodeLength(node) {\n    if (isTagNode(node) && Array.isArray(node.content)) {\n        return node.content.reduce((count, contentNode)=>{\n            return count + getNodeLength(contentNode);\n        }, 0);\n    }\n    if (isStringNode(node)) {\n        return String(node).length;\n    }\n    return 0;\n}\nfunction appendToNode(node, value) {\n    if (Array.isArray(node.content)) {\n        node.content.push(value);\n    }\n}\n/**\n * Replaces \" to &qquot;\n * @param {string} value\n */ function escapeAttrValue(value) {\n    return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#039;')// eslint-disable-next-line no-script-url\n    .replace(/(javascript|data|vbscript):/gi, '$1%3A');\n}\n/**\n * @deprecated use escapeAttrValue\n */ const escapeHTML = escapeAttrValue;\n/**\n * Accept name and value and return valid html5 attribute string\n */ function attrValue(name, value) {\n    // in case of performance\n    switch(typeof value){\n        case 'boolean':\n            return value ? `${name}` : '';\n        case 'number':\n            return `${name}=\"${value}\"`;\n        case 'string':\n            return `${name}=\"${escapeAttrValue(value)}\"`;\n        case 'object':\n            return `${name}=\"${escapeAttrValue(JSON.stringify(value))}\"`;\n        default:\n            return '';\n    }\n}\n/**\n * Transforms attrs to html params string\n * @example\n * attrsToString({ 'foo': true, 'bar': bar' }) => 'foo=\"true\" bar=\"bar\"'\n */ function attrsToString(values) {\n    // To avoid some malformed attributes\n    if (values == null) {\n        return '';\n    }\n    return keysReduce(values, (arr, key, obj)=>[\n            ...arr,\n            attrValue(key, obj[key])\n        ], [\n        ''\n    ]).join(' ');\n}\n/**\n * Gets value from\n * @example\n * getUniqAttr({ 'foo': true, 'bar': bar' }) => 'bar'\n */ function getUniqAttr(attrs) {\n    return keysReduce(attrs || {}, (res, key, obj)=>obj[key] === key ? obj[key] : null, null);\n}\nexport { attrsToString, attrValue, appendToNode, escapeHTML, escapeAttrValue, getNodeLength, getUniqAttr, isTagNode, isStringNode, isEOL };\n","import { OPEN_BRAKET, CLOSE_BRAKET, SLASH } from './char';\nimport { getUniqAttr, getNodeLength, appendToNode, attrsToString, attrValue, isTagNode } from './helpers';\nconst getTagAttrs = (tag, params)=>{\n    const uniqAttr = getUniqAttr(params);\n    if (uniqAttr) {\n        const tagAttr = attrValue(tag, uniqAttr);\n        const attrs = {\n            ...params\n        };\n        delete attrs[String(uniqAttr)];\n        const attrsStr = attrsToString(attrs);\n        return `${tagAttr}${attrsStr}`;\n    }\n    return `${tag}${attrsToString(params)}`;\n};\nconst renderContent = (content, openTag, closeTag)=>{\n    const toString = (node)=>{\n        if (isTagNode(node)) {\n            return node.toString({\n                openTag,\n                closeTag\n            });\n        }\n        return String(node);\n    };\n    if (Array.isArray(content)) {\n        return content.reduce((r, node)=>{\n            if (node !== null) {\n                return r + toString(node);\n            }\n            return r;\n        }, '');\n    }\n    if (content) {\n        return toString(content);\n    }\n    return null;\n};\nexport class TagNode {\n    attr(name, value) {\n        if (typeof value !== 'undefined') {\n            this.attrs[name] = value;\n        }\n        return this.attrs[name];\n    }\n    append(value) {\n        return appendToNode(this, value);\n    }\n    setStart(value) {\n        this.start = value;\n    }\n    setEnd(value) {\n        this.end = value;\n    }\n    get length() {\n        return getNodeLength(this);\n    }\n    toTagStart({ openTag = OPEN_BRAKET, closeTag = CLOSE_BRAKET } = {}) {\n        const tagAttrs = getTagAttrs(String(this.tag), this.attrs);\n        return `${openTag}${tagAttrs}${closeTag}`;\n    }\n    toTagEnd({ openTag = OPEN_BRAKET, closeTag = CLOSE_BRAKET } = {}) {\n        return `${openTag}${SLASH}${this.tag}${closeTag}`;\n    }\n    toTagNode() {\n        const newNode = new TagNode(String(this.tag).toLowerCase(), this.attrs, this.content);\n        if (this.start) {\n            newNode.setStart(this.start);\n        }\n        if (this.end) {\n            newNode.setEnd(this.end);\n        }\n        return newNode;\n    }\n    toString({ openTag = OPEN_BRAKET, closeTag = CLOSE_BRAKET } = {}) {\n        const content = this.content ? renderContent(this.content, openTag, closeTag) : '';\n        const tagStart = this.toTagStart({\n            openTag,\n            closeTag\n        });\n        if (this.content === null || Array.isArray(this.content) && this.content.length === 0) {\n            return tagStart;\n        }\n        return `${tagStart}${content}${this.toTagEnd({\n            openTag,\n            closeTag\n        })}`;\n    }\n    static create(tag, attrs = {}, content = null, start) {\n        const node = new TagNode(tag, attrs, content);\n        if (start) {\n            node.setStart(start);\n        }\n        return node;\n    }\n    static isOf(node, type) {\n        return node.tag === type;\n    }\n    constructor(tag, attrs, content){\n        this.tag = tag;\n        this.attrs = attrs;\n        this.content = content;\n    }\n}\n","import { OPEN_BRAKET, CLOSE_BRAKET, SLASH } from '@bbob/plugin-helper';\n// type, value, line, row, start pos, end pos\nconst TOKEN_TYPE_ID = 't'; // 0;\nconst TOKEN_VALUE_ID = 'v'; // 1;\nconst TOKEN_COLUMN_ID = 'r'; // 2;\nconst TOKEN_LINE_ID = 'l'; // 3;\nconst TOKEN_START_POS_ID = 's'; // 4;\nconst TOKEN_END_POS_ID = 'e'; // 5;\nconst TOKEN_TYPE_WORD = 1; // 'word';\nconst TOKEN_TYPE_TAG = 2; // 'tag';\nconst TOKEN_TYPE_ATTR_NAME = 3; // 'attr-name';\nconst TOKEN_TYPE_ATTR_VALUE = 4; // 'attr-value';\nconst TOKEN_TYPE_SPACE = 5; // 'space';\nconst TOKEN_TYPE_NEW_LINE = 6; // 'new-line';\nconst getTokenValue = (token)=>{\n    if (token && typeof token[TOKEN_VALUE_ID] !== 'undefined') {\n        return token[TOKEN_VALUE_ID];\n    }\n    return '';\n};\nconst getTokenLine = (token)=>token && token[TOKEN_LINE_ID] || 0;\nconst getTokenColumn = (token)=>token && token[TOKEN_COLUMN_ID] || 0;\nconst getStartPosition = (token)=>token && token[TOKEN_START_POS_ID] || 0;\nconst getEndPosition = (token)=>token && token[TOKEN_END_POS_ID] || 0;\nconst isTextToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_SPACE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_NEW_LINE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_WORD;\n    }\n    return false;\n};\nconst isTagToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_TAG;\n    }\n    return false;\n};\nconst isTagEnd = (token)=>getTokenValue(token).charCodeAt(0) === SLASH.charCodeAt(0);\nconst isTagStart = (token)=>!isTagEnd(token);\nconst isAttrNameToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_NAME;\n    }\n    return false;\n};\nconst isAttrValueToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_VALUE;\n    }\n    return false;\n};\nconst getTagName = (token)=>{\n    const value = getTokenValue(token);\n    return isTagEnd(token) ? value.slice(1) : value;\n};\nconst tokenToText = (token, openTag = OPEN_BRAKET, closeTag = CLOSE_BRAKET)=>{\n    let text = openTag;\n    text += getTokenValue(token);\n    text += closeTag;\n    return text;\n};\n/**\n * @export\n * @class Token\n */ class Token {\n    get type() {\n        return this[TOKEN_TYPE_ID];\n    }\n    isEmpty() {\n        return this[TOKEN_TYPE_ID] === 0 || isNaN(this[TOKEN_TYPE_ID]);\n    }\n    isText() {\n        return isTextToken(this);\n    }\n    isTag() {\n        return isTagToken(this);\n    }\n    isAttrName() {\n        return isAttrNameToken(this);\n    }\n    isAttrValue() {\n        return isAttrValueToken(this);\n    }\n    isStart() {\n        return isTagStart(this);\n    }\n    isEnd() {\n        return isTagEnd(this);\n    }\n    getName() {\n        return getTagName(this);\n    }\n    getValue() {\n        return getTokenValue(this);\n    }\n    getLine() {\n        return getTokenLine(this);\n    }\n    getColumn() {\n        return getTokenColumn(this);\n    }\n    getStart() {\n        return getStartPosition(this);\n    }\n    getEnd() {\n        return getEndPosition(this);\n    }\n    toString({ openTag = OPEN_BRAKET, closeTag = CLOSE_BRAKET } = {}) {\n        return tokenToText(this, openTag, closeTag);\n    }\n    constructor(type, value, row = 0, col = 0, start = 0, end = 0){\n        this[TOKEN_LINE_ID] = row;\n        this[TOKEN_COLUMN_ID] = col;\n        this[TOKEN_TYPE_ID] = type || 0;\n        this[TOKEN_VALUE_ID] = String(value);\n        this[TOKEN_START_POS_ID] = start;\n        this[TOKEN_END_POS_ID] = end;\n    }\n}\nexport const TYPE_ID = TOKEN_TYPE_ID;\nexport const VALUE_ID = TOKEN_VALUE_ID;\nexport const LINE_ID = TOKEN_LINE_ID;\nexport const COLUMN_ID = TOKEN_COLUMN_ID;\nexport const START_POS_ID = TOKEN_START_POS_ID;\nexport const END_POS_ID = TOKEN_END_POS_ID;\nexport const TYPE_WORD = TOKEN_TYPE_WORD;\nexport const TYPE_TAG = TOKEN_TYPE_TAG;\nexport const TYPE_ATTR_NAME = TOKEN_TYPE_ATTR_NAME;\nexport const TYPE_ATTR_VALUE = TOKEN_TYPE_ATTR_VALUE;\nexport const TYPE_SPACE = TOKEN_TYPE_SPACE;\nexport const TYPE_NEW_LINE = TOKEN_TYPE_NEW_LINE;\nexport { Token };\nexport default Token;\n","import { QUOTEMARK, BACKSLASH } from '@bbob/plugin-helper';\nexport class CharGrabber {\n    skip(num = 1, silent) {\n        this.c.pos += num;\n        if (this.o && this.o.onSkip && !silent) {\n            this.o.onSkip();\n        }\n    }\n    hasNext() {\n        return this.c.len > this.c.pos;\n    }\n    getCurr() {\n        if (typeof this.s[this.c.pos] === 'undefined') {\n            return '';\n        }\n        return this.s[this.c.pos];\n    }\n    getPos() {\n        return this.c.pos;\n    }\n    getLength() {\n        return this.c.len;\n    }\n    getRest() {\n        return this.s.substring(this.c.pos);\n    }\n    getNext() {\n        const nextPos = this.c.pos + 1;\n        return nextPos <= this.s.length - 1 ? this.s[nextPos] : null;\n    }\n    getPrev() {\n        const prevPos = this.c.pos - 1;\n        if (typeof this.s[prevPos] === 'undefined') {\n            return null;\n        }\n        return this.s[prevPos];\n    }\n    isLast() {\n        return this.c.pos === this.c.len;\n    }\n    includes(val) {\n        return this.s.indexOf(val, this.c.pos) >= 0;\n    }\n    grabWhile(condition, silent) {\n        let start = 0;\n        if (this.hasNext()) {\n            start = this.c.pos;\n            while(this.hasNext() && condition(this.getCurr())){\n                this.skip(1, silent);\n            }\n        }\n        return this.s.substring(start, this.c.pos);\n    }\n    grabN(num = 0) {\n        return this.s.substring(this.c.pos, this.c.pos + num);\n    }\n    /**\n   * Grabs rest of string until it find a char\n   */ substrUntilChar(char) {\n        const { pos } = this.c;\n        const idx = this.s.indexOf(char, pos);\n        return idx >= 0 ? this.s.substring(pos, idx) : '';\n    }\n    constructor(source, options = {}){\n        this.s = source;\n        this.c = {\n            pos: 0,\n            len: source.length\n        };\n        this.o = options;\n    }\n}\n/**\n * Creates a grabber wrapper for source string, that helps to iterate over string char by char\n */ export const createCharGrabber = (source, options)=>new CharGrabber(source, options);\n/**\n * Trims string from start and end by char\n * @example\n *  trimChar('*hello*', '*') ==> 'hello'\n */ export const trimChar = (str, charToRemove)=>{\n    while(str.charAt(0) === charToRemove){\n        // eslint-disable-next-line no-param-reassign\n        str = str.substring(1);\n    }\n    while(str.charAt(str.length - 1) === charToRemove){\n        // eslint-disable-next-line no-param-reassign\n        str = str.substring(0, str.length - 1);\n    }\n    return str;\n};\n/**\n * Unquotes \\\" to \"\n */ export const unquote = (str)=>str.replace(BACKSLASH + QUOTEMARK, QUOTEMARK);\n","/* eslint-disable no-plusplus,no-param-reassign */ import { OPEN_BRAKET, CLOSE_BRAKET, QUOTEMARK, BACKSLASH, SLASH, SPACE, TAB, EQ, N } from '@bbob/plugin-helper';\nimport { Token, TYPE_ATTR_NAME, TYPE_ATTR_VALUE, TYPE_NEW_LINE, TYPE_SPACE, TYPE_TAG, TYPE_WORD } from './Token';\nimport { createCharGrabber, trimChar, unquote } from './utils';\n// for cases <!-- -->\nconst EM = '!';\nexport function createTokenOfType(type, value, r = 0, cl = 0, p = 0, e = 0) {\n    return new Token(type, value, r, cl, p, e);\n}\nconst STATE_WORD = 0;\nconst STATE_TAG = 1;\nconst STATE_TAG_ATTRS = 2;\nconst TAG_STATE_NAME = 0;\nconst TAG_STATE_ATTR = 1;\nconst TAG_STATE_VALUE = 2;\nconst WHITESPACES = [\n    SPACE,\n    TAB\n];\nconst SPECIAL_CHARS = [\n    EQ,\n    SPACE,\n    TAB\n];\nconst END_POS_OFFSET = 2; // length + start position offset\nconst isWhiteSpace = (char)=>WHITESPACES.indexOf(char) >= 0;\nconst isEscapeChar = (char)=>char === BACKSLASH;\nconst isSpecialChar = (char)=>SPECIAL_CHARS.indexOf(char) >= 0;\nconst isNewLine = (char)=>char === N;\nconst unq = (val)=>unquote(trimChar(val, QUOTEMARK));\nexport function createLexer(buffer, options = {}) {\n    let row = 0;\n    let prevCol = 0;\n    let col = 0;\n    let tokenIndex = -1;\n    let stateMode = STATE_WORD;\n    let tagMode = TAG_STATE_NAME;\n    let contextFreeTag = '';\n    const tokens = new Array(Math.floor(buffer.length));\n    const openTag = options.openTag || OPEN_BRAKET;\n    const closeTag = options.closeTag || CLOSE_BRAKET;\n    const escapeTags = !!options.enableEscapeTags;\n    const contextFreeTags = (options.contextFreeTags || []).filter(Boolean).map((tag)=>tag.toLowerCase());\n    const caseFreeTags = options.caseFreeTags || false;\n    const nestedMap = new Map();\n    const onToken = options.onToken || (()=>{});\n    const RESERVED_CHARS = [\n        closeTag,\n        openTag,\n        QUOTEMARK,\n        BACKSLASH,\n        SPACE,\n        TAB,\n        EQ,\n        N,\n        EM\n    ];\n    const NOT_CHAR_TOKENS = [\n        openTag,\n        SPACE,\n        TAB,\n        N\n    ];\n    const isCharReserved = (char)=>RESERVED_CHARS.indexOf(char) >= 0;\n    const isCharToken = (char)=>NOT_CHAR_TOKENS.indexOf(char) === -1;\n    const isEscapableChar = (char)=>char === openTag || char === closeTag || char === BACKSLASH;\n    const onSkip = ()=>{\n        col++;\n    };\n    const checkContextFreeMode = (name, isClosingTag)=>{\n        if (contextFreeTag !== '' && isClosingTag) {\n            contextFreeTag = '';\n        }\n        if (contextFreeTag === '' && contextFreeTags.includes(name.toLowerCase())) {\n            contextFreeTag = name;\n        }\n    };\n    const chars = createCharGrabber(buffer, {\n        onSkip\n    });\n    /**\n   * Emits newly created token to subscriber\n   */ function emitToken(type, value, startPos, endPos) {\n        const token = createTokenOfType(type, value, row, prevCol, startPos, endPos);\n        onToken(token);\n        prevCol = col;\n        tokenIndex += 1;\n        tokens[tokenIndex] = token;\n    }\n    function nextTagState(tagChars, isSingleValueTag, masterStartPos) {\n        if (tagMode === TAG_STATE_ATTR) {\n            const validAttrName = (char)=>!(char === EQ || isWhiteSpace(char));\n            const name = tagChars.grabWhile(validAttrName);\n            const isEnd = tagChars.isLast();\n            const isValue = tagChars.getCurr() !== EQ;\n            tagChars.skip();\n            if (isEnd || isValue) {\n                emitToken(TYPE_ATTR_VALUE, unq(name));\n            } else {\n                emitToken(TYPE_ATTR_NAME, name);\n            }\n            if (isEnd) {\n                return TAG_STATE_NAME;\n            }\n            if (isValue) {\n                return TAG_STATE_ATTR;\n            }\n            return TAG_STATE_VALUE;\n        }\n        if (tagMode === TAG_STATE_VALUE) {\n            let stateSpecial = false;\n            const validAttrValue = (char)=>{\n                // const isEQ = char === EQ;\n                const isQM = char === QUOTEMARK;\n                const prevChar = tagChars.getPrev();\n                const nextChar = tagChars.getNext();\n                const isPrevSLASH = prevChar === BACKSLASH;\n                const isNextEQ = nextChar === EQ;\n                const isWS = isWhiteSpace(char);\n                // const isPrevWS = isWhiteSpace(prevChar);\n                const isNextWS = nextChar && isWhiteSpace(nextChar);\n                if (stateSpecial && isSpecialChar(char)) {\n                    return true;\n                }\n                if (isQM && !isPrevSLASH) {\n                    stateSpecial = !stateSpecial;\n                    if (!stateSpecial && !(isNextEQ || isNextWS)) {\n                        return false;\n                    }\n                }\n                if (!isSingleValueTag) {\n                    return !isWS;\n                // return (isEQ || isWS) === false;\n                }\n                return true;\n            };\n            const name = tagChars.grabWhile(validAttrValue);\n            tagChars.skip();\n            emitToken(TYPE_ATTR_VALUE, unq(name));\n            if (tagChars.getPrev() === QUOTEMARK) {\n                prevCol++;\n            }\n            if (tagChars.isLast()) {\n                return TAG_STATE_NAME;\n            }\n            return TAG_STATE_ATTR;\n        }\n        const start = masterStartPos + tagChars.getPos() - 1;\n        const validName = (char)=>!(char === EQ || isWhiteSpace(char) || tagChars.isLast());\n        const name = tagChars.grabWhile(validName);\n        emitToken(TYPE_TAG, name, start, masterStartPos + tagChars.getLength() + 1);\n        checkContextFreeMode(name);\n        tagChars.skip();\n        prevCol++;\n        // in cases when we has [url=someval]GET[/url] and we dont need to parse all\n        if (isSingleValueTag) {\n            return TAG_STATE_VALUE;\n        }\n        const hasEQ = tagChars.includes(EQ);\n        return hasEQ ? TAG_STATE_ATTR : TAG_STATE_VALUE;\n    }\n    function stateTag() {\n        const currChar = chars.getCurr();\n        const nextChar = chars.getNext();\n        chars.skip();\n        // detect case where we have '[My word [tag][/tag]' or we have '[My last line word'\n        const substr = chars.substrUntilChar(closeTag);\n        const hasInvalidChars = substr.length === 0 || substr.indexOf(openTag) >= 0;\n        if (nextChar && isCharReserved(nextChar) || hasInvalidChars || chars.isLast()) {\n            emitToken(TYPE_WORD, currChar);\n            return STATE_WORD;\n        }\n        // [myTag   ]\n        const isNoAttrsInTag = substr.indexOf(EQ) === -1;\n        // [/myTag]\n        const isClosingTag = substr[0] === SLASH;\n        if (isNoAttrsInTag || isClosingTag) {\n            const startPos = chars.getPos() - 1;\n            const name = chars.grabWhile((char)=>char !== closeTag);\n            const endPos = startPos + name.length + END_POS_OFFSET;\n            chars.skip(); // skip closeTag\n            emitToken(TYPE_TAG, name, startPos, endPos);\n            checkContextFreeMode(name, isClosingTag);\n            return STATE_WORD;\n        }\n        return STATE_TAG_ATTRS;\n    }\n    function stateAttrs() {\n        const startPos = chars.getPos();\n        const silent = true;\n        const tagStr = chars.grabWhile((char)=>char !== closeTag, silent);\n        const tagGrabber = createCharGrabber(tagStr, {\n            onSkip\n        });\n        const hasSpace = tagGrabber.includes(SPACE);\n        tagMode = TAG_STATE_NAME;\n        while(tagGrabber.hasNext()){\n            tagMode = nextTagState(tagGrabber, !hasSpace, startPos);\n        }\n        chars.skip(); // skip closeTag\n        return STATE_WORD;\n    }\n    function stateWord() {\n        if (isNewLine(chars.getCurr())) {\n            emitToken(TYPE_NEW_LINE, chars.getCurr());\n            chars.skip();\n            col = 0;\n            prevCol = 0;\n            row++;\n            return STATE_WORD;\n        }\n        if (isWhiteSpace(chars.getCurr())) {\n            const word = chars.grabWhile(isWhiteSpace);\n            emitToken(TYPE_SPACE, word);\n            return STATE_WORD;\n        }\n        if (chars.getCurr() === openTag) {\n            if (contextFreeTag) {\n                const fullTagLen = openTag.length + SLASH.length + contextFreeTag.length;\n                const fullTagName = `${openTag}${SLASH}${contextFreeTag}`;\n                const foundTag = chars.grabN(fullTagLen);\n                const isEndContextFreeMode = foundTag === fullTagName;\n                if (isEndContextFreeMode) {\n                    return STATE_TAG;\n                }\n            } else if (chars.includes(closeTag)) {\n                return STATE_TAG;\n            }\n            emitToken(TYPE_WORD, chars.getCurr());\n            chars.skip();\n            prevCol++;\n            return STATE_WORD;\n        }\n        if (escapeTags) {\n            if (isEscapeChar(chars.getCurr())) {\n                const currChar = chars.getCurr();\n                const nextChar = chars.getNext();\n                chars.skip(); // skip the \\ without emitting anything\n                if (nextChar && isEscapableChar(nextChar)) {\n                    chars.skip(); // skip past the [, ] or \\ as well\n                    emitToken(TYPE_WORD, nextChar);\n                    return STATE_WORD;\n                }\n                emitToken(TYPE_WORD, currChar);\n                return STATE_WORD;\n            }\n            const isChar = (char)=>isCharToken(char) && !isEscapeChar(char);\n            const word = chars.grabWhile(isChar);\n            emitToken(TYPE_WORD, word);\n            return STATE_WORD;\n        }\n        const word = chars.grabWhile(isCharToken);\n        emitToken(TYPE_WORD, word);\n        return STATE_WORD;\n    }\n    function tokenize() {\n        stateMode = STATE_WORD;\n        while(chars.hasNext()){\n            switch(stateMode){\n                case STATE_TAG:\n                    stateMode = stateTag();\n                    break;\n                case STATE_TAG_ATTRS:\n                    stateMode = stateAttrs();\n                    break;\n                case STATE_WORD:\n                default:\n                    stateMode = stateWord();\n                    break;\n            }\n        }\n        tokens.length = tokenIndex + 1;\n        return tokens;\n    }\n    function isTokenNested(tokenValue) {\n        const value = openTag + SLASH + tokenValue;\n        if (nestedMap.has(value)) {\n            return !!nestedMap.get(value);\n        } else {\n            const status = caseFreeTags ? buffer.toLowerCase().indexOf(value.toLowerCase()) > -1 : buffer.indexOf(value) > -1;\n            nestedMap.set(value, status);\n            return status;\n        }\n    }\n    return {\n        tokenize,\n        isTokenNested\n    };\n}\n","import { CLOSE_BRAKET, OPEN_BRAKET, TagNode, isTagNode } from \"@bbob/plugin-helper\";\nimport { createLexer } from \"./lexer\";\nclass NodeList {\n    last() {\n        if (Array.isArray(this.n) && this.n.length > 0 && typeof this.n[this.n.length - 1] !== \"undefined\") {\n            return this.n[this.n.length - 1];\n        }\n        return null;\n    }\n    flush() {\n        return this.n.length ? this.n.pop() : false;\n    }\n    push(value) {\n        this.n.push(value);\n    }\n    toArray() {\n        return this.n;\n    }\n    constructor(){\n        this.n = [];\n    }\n}\nconst createList = ()=>new NodeList();\nfunction parse(input, opts = {}) {\n    const options = opts;\n    const openTag = options.openTag || OPEN_BRAKET;\n    const closeTag = options.closeTag || CLOSE_BRAKET;\n    const onlyAllowTags = (options.onlyAllowTags || []).filter(Boolean).map((tag)=>tag.toLowerCase());\n    const caseFreeTags = options.caseFreeTags || false;\n    let tokenizer = null;\n    /**\n   * Result AST of nodes\n   * @private\n   * @type {NodeList}\n   */ const nodes = createList();\n    /**\n   * Temp buffer of nodes that's nested to another node\n   * @private\n   */ const nestedNodes = createList();\n    /**\n   * Temp buffer of nodes [tag..]...[/tag]\n   * @private\n   * @type {NodeList}\n   */ const tagNodes = createList();\n    /**\n   * Temp buffer of tag attributes\n   * @private\n   * @type {NodeList}\n   */ const tagNodesAttrName = createList();\n    /**\n   * Cache for nested tags checks\n   */ const nestedTagsMap = new Set();\n    function isTokenNested(token) {\n        const tokenValue = token.getValue();\n        const value = caseFreeTags ? tokenValue.toLowerCase() : tokenValue;\n        const { isTokenNested } = tokenizer || {};\n        if (!nestedTagsMap.has(value) && isTokenNested && isTokenNested(value)) {\n            nestedTagsMap.add(value);\n            return true;\n        }\n        return nestedTagsMap.has(value);\n    }\n    /**\n   * @private\n   */ function isTagNested(tagName) {\n        return Boolean(nestedTagsMap.has(caseFreeTags ? tagName.toLowerCase() : tagName));\n    }\n    /**\n   * @private\n   */ function isAllowedTag(value) {\n        if (onlyAllowTags.length) {\n            return onlyAllowTags.indexOf(value.toLowerCase()) >= 0;\n        }\n        return true;\n    }\n    /**\n   * Flushes temp tag nodes and its attributes buffers\n   * @private\n   */ function flushTagNodes() {\n        if (tagNodes.flush()) {\n            tagNodesAttrName.flush();\n        }\n    }\n    /**\n   * @private\n   */ function getNodes() {\n        const lastNestedNode = nestedNodes.last();\n        if (lastNestedNode && isTagNode(lastNestedNode)) {\n            return lastNestedNode.content;\n        }\n        return nodes.toArray();\n    }\n    /**\n   * @private\n   */ function appendNodeAsString(nodes, node, isNested = true) {\n        if (Array.isArray(nodes) && typeof node !== \"undefined\") {\n            nodes.push(node.toTagStart({\n                openTag,\n                closeTag\n            }));\n            if (Array.isArray(node.content) && node.content.length) {\n                node.content.forEach((item)=>{\n                    nodes.push(item);\n                });\n                if (isNested) {\n                    nodes.push(node.toTagEnd({\n                        openTag,\n                        closeTag\n                    }));\n                }\n            }\n        }\n    }\n    /**\n   * @private\n   */ function appendNodes(nodes, node) {\n        if (Array.isArray(nodes) && typeof node !== \"undefined\") {\n            if (isTagNode(node)) {\n                if (isAllowedTag(node.tag)) {\n                    nodes.push(node.toTagNode());\n                } else {\n                    appendNodeAsString(nodes, node);\n                }\n            } else {\n                nodes.push(node);\n            }\n        }\n    }\n    /**\n   * @private\n   * @param {Token} token\n   */ function handleTagStart(token) {\n        flushTagNodes();\n        const tagNode = TagNode.create(token.getValue(), {}, [], {\n            from: token.getStart(),\n            to: token.getEnd()\n        });\n        const isNested = isTokenNested(token);\n        tagNodes.push(tagNode);\n        if (isNested) {\n            nestedNodes.push(tagNode);\n        } else {\n            const nodes = getNodes();\n            appendNodes(nodes, tagNode);\n        }\n    }\n    /**\n   * @private\n   * @param {Token} token\n   */ function handleTagEnd(token) {\n        const tagName = token.getValue().slice(1);\n        const lastNestedNode = nestedNodes.flush();\n        flushTagNodes();\n        if (lastNestedNode) {\n            const nodes = getNodes();\n            if (isTagNode(lastNestedNode)) {\n                lastNestedNode.setEnd({\n                    from: token.getStart(),\n                    to: token.getEnd()\n                });\n            }\n            appendNodes(nodes, lastNestedNode);\n        } else if (!isTagNested(tagName)) {\n            const nodes = getNodes();\n            appendNodes(nodes, token.toString({\n                openTag,\n                closeTag\n            }));\n        } else if (typeof options.onError === \"function\") {\n            const tag = token.getValue();\n            const line = token.getLine();\n            const column = token.getColumn();\n            options.onError({\n                tagName: tag,\n                lineNumber: line,\n                columnNumber: column\n            });\n        }\n    }\n    /**\n   * @private\n   * @param {Token} token\n   */ function handleTag(token) {\n        // [tag]\n        if (token.isStart()) {\n            handleTagStart(token);\n        }\n        // [/tag]\n        if (token.isEnd()) {\n            handleTagEnd(token);\n        }\n    }\n    /**\n   * @private\n   * @param {Token} token\n   */ function handleNode(token) {\n        /**\n     * @type {TagNode}\n     */ const activeTagNode = tagNodes.last();\n        const tokenValue = token.getValue();\n        const isNested = isTagNested(token.toString());\n        const nodes = getNodes();\n        if (activeTagNode !== null) {\n            if (token.isAttrName()) {\n                tagNodesAttrName.push(tokenValue);\n                const attrName = tagNodesAttrName.last();\n                if (attrName) {\n                    activeTagNode.attr(attrName, \"\");\n                }\n            } else if (token.isAttrValue()) {\n                const attrName = tagNodesAttrName.last();\n                if (attrName) {\n                    activeTagNode.attr(attrName, tokenValue);\n                    tagNodesAttrName.flush();\n                } else {\n                    activeTagNode.attr(tokenValue, tokenValue);\n                }\n            } else if (token.isText()) {\n                if (isNested) {\n                    activeTagNode.append(tokenValue);\n                } else {\n                    appendNodes(nodes, tokenValue);\n                }\n            } else if (token.isTag()) {\n                // if tag is not allowed, just pass it as is\n                appendNodes(nodes, token.toString({\n                    openTag,\n                    closeTag\n                }));\n            }\n        } else if (token.isText()) {\n            appendNodes(nodes, tokenValue);\n        } else if (token.isTag()) {\n            // if tag is not allowed, just pass it as is\n            appendNodes(nodes, token.toString({\n                openTag,\n                closeTag\n            }));\n        }\n    }\n    /**\n   * @private\n   * @param {Token} token\n   */ function onToken(token) {\n        if (token.isTag()) {\n            handleTag(token);\n        } else {\n            handleNode(token);\n        }\n    }\n    const lexer = opts.createTokenizer ? opts.createTokenizer : createLexer;\n    tokenizer = lexer(input, {\n        onToken,\n        openTag,\n        closeTag,\n        onlyAllowTags: options.onlyAllowTags,\n        contextFreeTags: options.contextFreeTags,\n        caseFreeTags: options.caseFreeTags,\n        enableEscapeTags: options.enableEscapeTags\n    });\n    // eslint-disable-next-line no-unused-vars\n    const tokens = tokenizer.tokenize();\n    // handles situations where we open tag, but forgot close them\n    // for ex [q]test[/q][u]some[/u][q]some [u]some[/u] // forgot to close [/q]\n    // so we need to flush nested content to nodes array\n    const lastNestedNode = nestedNodes.flush();\n    if (lastNestedNode !== null && lastNestedNode && isTagNode(lastNestedNode) && isTagNested(lastNestedNode.tag)) {\n        appendNodeAsString(getNodes(), lastNestedNode, false);\n    }\n    return nodes.toArray();\n}\nexport { parse };\nexport default parse;\n","/* eslint-disable no-plusplus */ const isObj = (value)=>typeof value === 'object' && value !== null;\nconst isBool = (value)=>typeof value === 'boolean';\nexport function iterate(t, cb) {\n    const tree = t;\n    if (Array.isArray(tree)) {\n        for(let idx = 0; idx < tree.length; idx++){\n            tree[idx] = iterate(cb(tree[idx]), cb);\n        }\n    } else if (isObj(tree) && 'content' in tree) {\n        iterate(tree.content, cb);\n    }\n    return tree;\n}\nexport function same(expected, actual) {\n    if (typeof expected !== typeof actual) {\n        return false;\n    }\n    if (!isObj(expected) || expected === null) {\n        return expected === actual;\n    }\n    if (Array.isArray(expected)) {\n        return expected.every((exp)=>[].some.call(actual, (act)=>same(exp, act)));\n    }\n    if (isObj(expected) && isObj(actual)) {\n        return Object.keys(expected).every((key)=>{\n            const ao = actual[key];\n            const eo = expected[key];\n            if (isObj(eo) && isObj(ao)) {\n                return same(eo, ao);\n            }\n            if (isBool(eo)) {\n                return eo !== (ao === null);\n            }\n            return ao === eo;\n        });\n    }\n    return false;\n}\nexport function match(t, expression, cb) {\n    if (Array.isArray(expression)) {\n        return iterate(t, (node)=>{\n            for(let idx = 0; idx < expression.length; idx++){\n                if (same(expression[idx], node)) {\n                    return cb(node);\n                }\n            }\n            return node;\n        });\n    }\n    return iterate(t, (node)=>same(expression, node) ? cb(node) : node);\n}\n","import { parse } from '@bbob/parser';\nimport { iterate, match } from './utils';\nimport { C1, C2 } from './errors';\nexport function createTree(tree, options) {\n    const extendedTree = tree;\n    extendedTree.messages = [\n        ...extendedTree.messages || []\n    ];\n    extendedTree.options = {\n        ...options,\n        ...extendedTree.options\n    };\n    extendedTree.walk = function walkNodes(cb) {\n        return iterate(this, cb);\n    };\n    extendedTree.match = function matchNodes(expr, cb) {\n        return match(this, expr, cb);\n    };\n    return extendedTree;\n}\nexport default function bbob(plugs) {\n    const plugins = typeof plugs === 'function' ? [\n        plugs\n    ] : plugs || [];\n    const mockRender = ()=>\"\";\n    return {\n        process (input, opts) {\n            const options = opts || {\n                skipParse: false,\n                parser: parse,\n                render: mockRender,\n                data: null\n            };\n            const parseFn = options.parser || parse;\n            const renderFn = options.render;\n            const data = options.data || null;\n            if (typeof parseFn !== 'function') {\n                throw new Error(C1);\n            }\n            // raw tree before modification with plugins\n            const raw = options.skipParse && Array.isArray(input) ? input : parseFn(input, options);\n            let tree = options.skipParse && Array.isArray(input) ? createTree(input || [], options) : createTree(raw, options);\n            for(let idx = 0; idx < plugins.length; idx++){\n                const plugin = plugins[idx];\n                if (typeof plugin === 'function' && renderFn) {\n                    const newTree = plugin(tree, {\n                        parse: parseFn,\n                        render: renderFn,\n                        iterate,\n                        data\n                    });\n                    tree = createTree(newTree || tree, options);\n                }\n            }\n            return {\n                get html () {\n                    if (typeof renderFn !== 'function') {\n                        throw new Error(C2);\n                    }\n                    return renderFn(tree, tree.options);\n                },\n                tree,\n                raw,\n                messages: tree.messages\n            };\n        }\n    };\n}\n","import core from '@bbob/core';\nimport { attrsToString, isTagNode } from '@bbob/plugin-helper';\nconst SELFCLOSE_END_TAG = '/>';\nconst CLOSE_START_TAG = '</';\nconst START_TAG = '<';\nconst END_TAG = '>';\nfunction renderNode(node, options) {\n    const { stripTags = false } = options || {};\n    if (typeof node === 'undefined' || node === null) {\n        return '';\n    }\n    if (typeof node === 'string' || typeof node === 'number') {\n        return String(node);\n    }\n    if (Array.isArray(node)) {\n        return render(node, options);\n    }\n    if (isTagNode(node)) {\n        if (stripTags) {\n            return render(node.content, options);\n        }\n        const attrs = attrsToString(node.attrs);\n        if (node.content === null) {\n            return START_TAG + node.tag + attrs + SELFCLOSE_END_TAG;\n        }\n        return START_TAG + node.tag + attrs + END_TAG + render(node.content, options) + CLOSE_START_TAG + node.tag + END_TAG;\n    }\n    return '';\n}\nexport function render(nodes, options) {\n    if (nodes && Array.isArray(nodes)) {\n        return nodes.reduce((r, node)=>r + renderNode(node, options), '');\n    }\n    if (nodes) {\n        return renderNode(nodes, options);\n    }\n    return '';\n}\nexport function html(source, plugins, options) {\n    return core(plugins).process(source, {\n        ...options,\n        render: render\n    }).html;\n}\nexport default html;\n","/**\n * Generate the node object.\n *\n * Contains additional logic to help break any unintended side effects of the top down parsing of bbob.\n * @param {string} tag name of the tag\n * @param {Object<string, boolean|string|string[]>} attrs attributes of the tag\n * @param {any} content contents of the tag. `[]` will create an empty tag. `null` will create a self closing tag\n *\n * @example\n * ```\n * toNode(\"div\", { class: \"class\" }, \"content\")\n * ```\n * becomes\n * ```\n * {\n *  tag: \"div\",\n *  attrs: { class: \"class\" },\n *  content: \"content\",\n *  gen: true,\n * }\n */\nconst toNode = (tag, attrs, content = []) => ({\n  tag,\n  attrs,\n  content,\n  gen: true,\n});\n\n/**\n * Preprocess attributes of a node to either return the default single attribute\n * or return a keyed attribute list\n * @param {import('@bbob/types').TagNode} node bbcode node to process\n * @param {string} [raw] raw string. Only include if the single attribute is allowed to have spaces\n * @returns processed attributes\n */\nconst preprocessAttr = (node, raw) => {\n  const keys = Object.keys(node.attrs).join(\" \");\n  const vals = Object.values(node.attrs).join(\" \");\n  if (keys !== vals) {\n    // [tag key=val]\n    return node.attrs;\n  }\n  if (!raw || !node.start) {\n    return {\n      _default: vals,\n    };\n  }\n  // [tag=attr]\n  // node.start.from = 0\n  // node.start.to = 10\n  const nodeRaw = raw.substring(node.start.from, node.start.to);\n  if (!nodeRaw.includes(\"=\")) {\n    // [tag] or [tag attr]\n    return node.attrs;\n  }\n  const openTagParts = nodeRaw.split(\"=\");\n  if (openTagParts.length !== 2) {\n    return node.attrs;\n  }\n  let val = openTagParts[1].slice(0, -1).trim(); // `attr` or `\"attr\"`\n  if (val.startsWith('\"') && val.endsWith('\"')) {\n    val = val.slice(1, -1);\n  }\n  return {\n    _default: val,\n  };\n};\n\n/**\n * Attempts to return tag into its original form with proper attributes\n * @returns string of tag start\n */\nconst toOriginalStartTag = (node, raw) => {\n  if (node.start) {\n    return raw.substring(node.start.from, node.start.to);\n  }\n  if (!node.attrs) {\n    return `[${node.tag}]`;\n  }\n  const attrs = preprocessAttr(node, raw);\n  if (attrs._default) {\n    return `[${node.tag}=${attrs._default}]`;\n  } else {\n    return node.toTagStart();\n  }\n};\n\n/**\n * Attempts to return tag into its original form\n * @returns string of tag end\n */\nconst toOriginalEndTag = (node, raw) => {\n  if (node.end) {\n    return raw.substring(node.end.from, node.end.to);\n  }\n  return node.toTagEnd();\n};\n\n/**\n * Given a string, find the first position of a regex match\n * @param {string} string to test against\n * @param {RegExp} regex to test with\n * @param {number} startpos starting position. Defaults to 0\n * @returns index of the first match of the regex in the string\n */\nconst regexIndexOf = (string, regex, startpos) => {\n  const indexOf = string.substring(startpos || 0).search(regex);\n  return indexOf >= 0 ? indexOf + (startpos || 0) : indexOf;\n};\n\nconst MD_NEWLINE_INJECT = \"<!-- bbcode injected newlines -->\\n\\n\";\nconst MD_NEWLINE_PRE_INJECT = \"\\n\\n<!-- bbcode pre injected newlines -->\";\nconst MD_NEWLINE_INJECT_COMMENT = \"<!-- bbcode injected newlines -->\";\n\nconst URL_REGEX =\n  /(http|ftp|https|upload):\\/\\/([\\w_-]+(?:(?:\\.[\\w_-]+)+))([\\w.,@?^=%&:\\/~+#-]*[\\w@?^=%&\\/~+#-])/;\nconst MD_URL_REGEX =\n  /\\!?\\[.*\\]\\((http|ftp|https|upload):\\/\\/([\\w_-]+(?:(?:\\.[\\w_-]+)+))([\\w.,@?^=%&:\\/~+#-]*[\\w@?^=%&\\/~+#-])\\)/;\nconst URL_REGEX_SINGLE_LINE = new RegExp(`^${URL_REGEX.source}|${MD_URL_REGEX.source}$`);\nconst ESCAPABLES_REGEX =\n  /((\\n|^)(?<fence>```+|~~~+)(?<fenceInfo>.*\\n))|(?<bbcode>\\[(?<bbcodeTag>i?code|plain)(=.*)?\\])|(?<backtick>(?<tickStart>`{1,2})(.*)(?<tickEnd>\\k<tickStart>))/im;\nconst MD_TABLE_REGEX = /^(\\|[^\\n]+\\|\\r?\\n)((?:\\| ?:?[-]+:? ?)+\\|)(\\n(?:\\|[^\\n]+\\|\\r?\\n?)*)?$/m;\n\nconst MD_BROKEN_ORDERED_LIST = \"</ol>\\n<br><ol>\";\nconst MD_BROKEN_UNORDERED_LIST = \"</ul>\\n<br><ul>\";\nconst MD_BROKEN_BLOCKQUOTE = \"</blockquote>\\n<blockquote>\";\n\n/**\n * Generates a random GUID.\n *\n * Mini Racer doesn't have the crypto module, so we can't use the built-in `crypto.randomUUID` function.\n * @returns {string} a GUID\n */\nfunction generateGUID() {\n  let d = new Date().getTime();\n  if (window.performance && typeof window.performance.now === \"function\") {\n    d += performance.now(); //use high-precision timer if available\n  }\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    // eslint-disable-next-line no-bitwise\n    const r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    // eslint-disable-next-line no-bitwise\n    return (c === \"x\" ? r : (r & 0x3) | 0x8).toString(16);\n  });\n}\n\nexport {\n  toNode,\n  toOriginalStartTag,\n  toOriginalEndTag,\n  generateGUID,\n  preprocessAttr,\n  regexIndexOf,\n  MD_NEWLINE_INJECT,\n  MD_NEWLINE_INJECT_COMMENT,\n  MD_NEWLINE_PRE_INJECT,\n  URL_REGEX,\n  MD_URL_REGEX,\n  MD_TABLE_REGEX,\n  URL_REGEX_SINGLE_LINE,\n  ESCAPABLES_REGEX,\n  MD_BROKEN_ORDERED_LIST,\n  MD_BROKEN_UNORDERED_LIST,\n  MD_BROKEN_BLOCKQUOTE,\n};\n","/**\n * Plugin that converts line breaks to `<br/>` tags.\n * To use, put as function similar to the presets.\n *\n * If a node is marked with `noLineBreakConversion`, then it'll skip the parsing the children\n *\n * @example\n * ```ts\n * const output = bbob([preset(), lineBreakPlugin()]).process(input, {render}).html\n * ```\n */\nimport { isEOL } from \"@bbob/plugin-helper\";\nimport { MD_NEWLINE_INJECT, MD_NEWLINE_PRE_INJECT, URL_REGEX_SINGLE_LINE } from \"../utils/common\";\n\nconst isObj = (value) => typeof value === \"object\";\nconst isString = (value) => typeof value === \"string\";\n\n/**\n * Walks the tree of nodes. Will add `br` tag to all `\\n` in format that can be used in any renderer.\n * Preserves \\n so that markdown-it doesn't try to treat everything like a block\n *\n * If a node has the property noLineBreakConversion is encountered, will skip parsing children.\n * @param t tree of nodes to be processed\n * @returns modified tree\n */\nconst walk = (t, disableLineBreakConversion = false) => {\n  const tree = t;\n\n  if (Array.isArray(tree)) {\n    reduceWordsToLines(tree);\n    if (tree.some(isString)) {\n      // array contains strings. Might be md compatible\n      tree.unshift(MD_NEWLINE_INJECT);\n      tree.push(MD_NEWLINE_INJECT);\n    }\n    for (let idx = 0; idx < tree.length; idx++) {\n      const child = walk(tree[idx], disableLineBreakConversion);\n      if (Array.isArray(child)) {\n        tree.splice(idx, 1, ...child);\n        idx += child.length - 1;\n      } else {\n        tree[idx] = child;\n      }\n    }\n  } else if (tree && isObj(tree) && tree.content) {\n    if (tree.isWhitespaceSensitive) {\n      // applies only to [code] and [icode]\n      // stop walk. children won't be parsed to have <br>\n      return tree.tag ? tree : tree.content;\n    }\n    if (tree.disableLineBreakConversion) {\n      disableLineBreakConversion = true;\n    }\n    walk(tree.content, disableLineBreakConversion);\n    return tree.tag ? tree : tree.content;\n  } else if (isString(tree) && URL_REGEX_SINGLE_LINE.test(tree.trim())) {\n    // if the entire string is a URL, then it should be prepared for onebox.\n    // BBob separates strings by newlines anyway, so we can already assume this is sitting on its own line\n    // MD_NEWLINE_INJECT is already replacing newline came before or the start of the array,\n    // so we only need to make sure \\n\\n is added after the URL\n    return [tree, MD_NEWLINE_PRE_INJECT];\n  }\n\n  if (isString(tree) && isEOL(tree)) {\n    return disableLineBreakConversion\n      ? [\"\\n\", MD_NEWLINE_INJECT]\n      : [{ tag: \"br\", content: null }, MD_NEWLINE_INJECT];\n  }\n\n  return tree;\n};\n\n/**\n * Reduces the list into lines, so that we can process them by line.\n * Performs in place.\n * @param {(string|Object)[]} words\n */\nconst reduceWordsToLines = (words) => {\n  let rightIdx = words.findLastIndex((w) => isString(w) && !isEOL(w)) + 1;\n\n  for (let i = rightIdx - 1; i >= 0; i--) {\n    if (isString(words[i]) && !isEOL(words[i])) {\n      continue;\n    }\n    if (isEOL(words[i])) {\n      if (i !== rightIdx - 1) {\n        words.splice(i + 1, rightIdx - i - 1, words.slice(i + 1, rightIdx).join(\"\"));\n      }\n      rightIdx = i;\n      continue;\n    }\n    if (isObj(words[i])) {\n      if (i !== rightIdx - 1) {\n        words.splice(i + 1, rightIdx - i - 1, words.slice(i + 1, rightIdx).join(\"\"));\n      }\n      rightIdx = i;\n    }\n  }\n\n  if (0 !== rightIdx) {\n    words.splice(0, rightIdx, words.slice(0, rightIdx).join(\"\"));\n  }\n};\n\n/**\n * Converts `\\n` to `<br/>` self closing tag. Supply this as the last plugin in the preset lists\n *\n * @example converts all line breaks to br\n * ```ts\n * const output = bbob([preset(), lineBreakPlugin()]).process(input, {render}).html\n * ```\n * @example will not convert line breaks inside [nobr]\n * ```ts\n * const nobr = (node: TagNode) => {return { disableLineBreakConversion: true, content: node.content }}; \\\\ tag in preset\n * ...\n * const output = bbob([preset(), lineBreakPlugin()]).process(input, {render}).html\n * ```\n * @returns plugin to be used in BBob process\n */\nexport const lineBreakPlugin = () => {\n  return (tree) => walk(tree);\n};\n","/**\n * Plugin that converts consecutive normal spaces (U+0020) to non-breaking spaces (U+00A0).\n * To use, put as function similar to the presets.\n *\n *\n * @example\n * ```ts\n * const output = bbob([preset(), , preserveWhitespace(), lineBreakPlugin()]).process(input, {render}).html\n * ```\n */\nimport { isStringNode } from \"@bbob/plugin-helper\";\n\n/**\n * Checks if input is an object\n * @param value input\n * @returns if value is an object\n */\nconst isObj = (value) => typeof value === \"object\";\n\n/**\n * Walks the tree of nodes. Checks for node of consecutive spaces. If found replaces every space in\n * node with a nonbreaking space.\n * Preserves multiple spaces so html won't truncate them.\n *\n * Walks through entire tree.\n * @param t tree of nodes to be processed\n * @returns modified tree\n */\nconst walk = (t) => {\n  const tree = t;\n\n  if (Array.isArray(tree)) {\n    for (let idx = 0; idx < tree.length; idx++) {\n      const child = walk(tree[idx]);\n      if (Array.isArray(child)) {\n        tree.splice(idx, 1, ...child);\n        idx += child.length - 1;\n      } else {\n        tree[idx] = child;\n      }\n    }\n  } else if (tree && isObj(tree) && tree.content) {\n    walk(tree.content);\n  }\n\n  //Bbob breaks up nodes by the presence of normal spaces.\n  //So a node with a normal space can only have normal spaces in that node.\n  if (isStringNode(tree)) {\n    if (tree.length > 1 && tree[0] === \" \") {\n      let numSpaces = tree.length;\n      return [String.fromCharCode(160).repeat(numSpaces)];\n    }\n  }\n\n  return tree;\n};\n\n/**\n * Converts consecutive normal spaces (U+0020) to nonbreaking spaces (U+00A0).\n * Supply this as a plugin in the preset lists.\n *\n * @example converts consecutive normal spaces (U+0020) to nonbreaking spaces (U+00A0)\n * ```ts\n * const output = bbob([preset(), preserveWhitespace(), lineBreakPlugin()]).process(input, {render}).html\n * ```\n *\n * @returns plugin to be used in BBob process\n */\nexport const preserveWhitespace = () => {\n  return (tree) => walk(tree);\n};\n","import { isTagNode } from \"@bbob/plugin-helper\";\nconst CONSECUTIVE_NEWLINE_REGEX = /\\n{2,}/gm;\n\n/**\n * Removes empty lines from a string\n * @param {string} text\n */\nconst removeEmptyLines = (text) => {\n  return text.replace(CONSECUTIVE_NEWLINE_REGEX, \"\\n\");\n};\n\n/**\n * Removes empty lines from attributes\n * @type {import('@bbob/types').BBobPluginFunction}\n */\nexport const removeEmptyLinePlugin = (tree) => {\n  return tree.walk((node) => {\n    if (isTagNode(node) && node.attrs) {\n      Object.keys(node.attrs).forEach((key) => {\n        if (typeof node.attrs[key] === \"string\") {\n          node.attrs[key] = removeEmptyLines(node.attrs[key]);\n        }\n      });\n    }\n    return node;\n  });\n};\n","import { isTagNode } from \"@bbob/plugin-helper\";\nexport function process(tags, tree, core, options) {\n    return tree.walk((node)=>{\n        if (isTagNode(node)) {\n            const tag = node.tag;\n            const tagCallback = tags[tag];\n            if (typeof tagCallback === \"function\") {\n                return tagCallback(node, core, options);\n            }\n        }\n        return node;\n    });\n}\n/**\n * Create a preset plugin for @bbob/core\n */ function createPreset(defTags, processor = process) {\n    const presetFactory = (opts)=>{\n        presetFactory.options = Object.assign(presetFactory.options || {}, opts);\n        function presetExecutor(tree, core) {\n            return processor(defTags, tree, core, presetFactory.options || {});\n        }\n        presetExecutor.options = presetFactory.options;\n        return presetExecutor;\n    };\n    presetFactory.extend = function presetExtend(callback) {\n        const newTags = callback(defTags, presetFactory.options);\n        return createPreset(newTags, processor);\n    };\n    return presetFactory;\n}\nexport { createPreset };\nexport default createPreset;\n","import { isStringNode, isTagNode, TagNode } from \"@bbob/plugin-helper\";\nimport {\n  generateGUID,\n  preprocessAttr,\n  regexIndexOf,\n  toNode,\n  toOriginalEndTag,\n  toOriginalStartTag,\n} from \"../utils/common\";\n\nconst SLIDE_TITLE_OPEN = Symbol(\"slide-title-open\");\nconst SLIDE_TITLE_CLOSE = Symbol(\"slide-title-close\");\nconst SLIDE_CLOSE = Symbol(\"slide-close\");\nconst SLIDE_REGEX =\n  /(?<slideTitleOpen>\\{slide=)|(?<slideTitleClose>\\})|(?<slideClose>\\{\\/slide\\})/i;\n\n/**\n * Adds the accordion tag\n * [accordion]{slide=name}content{/slide}[/accordion]\n *\n * [accordion][slide=name]content[/slide][/accordion]\n */\nconst accordion = (node, options) => {\n  const groupId = generateGUID();\n\n  // add support for existing {slide} tags style, due to copious amounts of existing content\n  // also the only way to get true custom content inside a slide due to nesting limitations\n  const markedContent = generateSlideMarkersFromContent(node.content);\n  const generatedSlides = generateSlidesFromMarkers(markedContent);\n\n  const filteredContent = generatedSlides\n    .filter((n) => isTagNode(n) && n.tag === \"slide\")\n    .map((content) => {\n      content.isValid = true;\n      content.groupId = groupId;\n      return content;\n    });\n  if (!filteredContent.length) {\n    // no [slide] tags found\n    return [\n      toOriginalStartTag(node, options.data.raw),\n      ...node.content,\n      toOriginalEndTag(node, options.data.raw),\n    ];\n  }\n  const attrs = preprocessAttr(node, options.data.raw);\n\n  if (attrs._default) {\n    /** @type {string[]} */\n    const customSettings = attrs._default.split(\"|\").map((s) => s.trim());\n    const lastValidAlignment = customSettings\n      .filter((s) => [\"bright\", \"bcenter\", \"bleft\", \"fleft\", \"fright\"].includes(s))\n      .pop();\n    if (lastValidAlignment) {\n      attrs.align ??= lastValidAlignment;\n    }\n\n    if (\n      customSettings.some((s) => s.endsWith(\"px\")) ||\n      customSettings.some((s) => s.endsWith(\"%\"))\n    ) {\n      attrs.width ??= customSettings.find((s) => s.endsWith(\"px\") || s.endsWith(\"%\"));\n    }\n  }\n\n  let classes = attrs.align?.toLowerCase() || \"\";\n  let style = \"\";\n  if (attrs.width?.endsWith(\"px\") || attrs.width?.endsWith(\"%\")) {\n    style = `width: ${attrs.width};`;\n  }\n  return toNode(\n    \"div\",\n    { class: \"bb-accordion \" + classes, \"data-group-id\": groupId, style },\n    filteredContent,\n  );\n};\n\n/**\n * Locates and splits all {slide} tag components into their respective parts while preserving remaining content\n * @param {(TagNode|string)[]} contentArr node content of the accordion tag\n *\n * @example\n * ```\n * [\"{slide=test}\", \"lorem ipsum\", \"{/slide}\"]\n * ```\n * becomes\n * ```\n * [SLIDE_TITLE_OPEN, \"test\", SLIDE_TITLE_CLOSE, \"lorem ipsum\", SLIDE_CLOSE]\n * ```\n */\nfunction generateSlideMarkersFromContent(contentArr) {\n  contentArr = [...contentArr]; // shallow clone. object nodes are not modified anyway\n\n  const newArr = [];\n  while (contentArr.length > 0) {\n    const content = contentArr[0];\n    if (isTagNode(content)) {\n      newArr.push(contentArr.shift());\n      continue;\n    }\n    const foundIndex = regexIndexOf(content, SLIDE_REGEX);\n    if (foundIndex === -1) {\n      newArr.push(contentArr.shift());\n      continue;\n    }\n    const match = content.match(SLIDE_REGEX);\n    const preContent = content.slice(0, foundIndex);\n    const postContent = content.slice(foundIndex + match[0].length);\n    if (preContent.length) {\n      newArr.push(preContent);\n    }\n    if (match.groups.slideTitleOpen) {\n      newArr.push(SLIDE_TITLE_OPEN);\n    }\n    if (match.groups.slideTitleClose) {\n      newArr.push(SLIDE_TITLE_CLOSE);\n    }\n    if (match.groups.slideClose) {\n      newArr.push(SLIDE_CLOSE);\n    }\n    if (postContent.length) {\n      contentArr[0] = postContent;\n    } else {\n      contentArr.shift();\n    }\n  }\n\n  return newArr;\n}\n\n/**\n * Generates slide nodes from markers\n * @param {(string | typeof SLIDE_TITLE_OPEN | typeof SLIDE_TITLE_CLOSE | typeof SLIDE_CLOSE | TagNode)[]} markedContent\n */\nfunction generateSlidesFromMarkers(markedContent) {\n  const nodes = [];\n  let currentSlide = null;\n  /** @type {typeof SLIDE_TITLE_OPEN | typeof SLIDE_TITLE_CLOSE | null} */\n  let prevMarker = null;\n  for (const content of markedContent) {\n    if (content === SLIDE_TITLE_OPEN && prevMarker === null) {\n      currentSlide = TagNode.create(\"slide\");\n      currentSlide.content = [];\n      currentSlide.customTitle = [];\n      prevMarker = SLIDE_TITLE_OPEN;\n    } else if (content === SLIDE_TITLE_CLOSE && prevMarker === SLIDE_TITLE_OPEN) {\n      prevMarker = SLIDE_TITLE_CLOSE;\n      continue;\n    } else if (content === SLIDE_CLOSE && currentSlide && prevMarker === SLIDE_TITLE_CLOSE) {\n      nodes.push(currentSlide);\n      currentSlide = null;\n      prevMarker = null;\n    } else if (currentSlide) {\n      if (prevMarker === SLIDE_TITLE_OPEN) {\n        currentSlide.customTitle.push(markerToString(content));\n      } else {\n        currentSlide.content.push(markerToString(content));\n      }\n    } else {\n      // no slide open, just add content\n      nodes.push(markerToString(content));\n    }\n  }\n  return nodes;\n}\n\n/**\n * Processes content into a string. Catches stray markers and converts them back into a string\n * @param {string | typeof SLIDE_TITLE_OPEN | typeof SLIDE_TITLE_CLOSE | typeof SLIDE_CLOSE} marker\n * @returns expected string\n */\nfunction markerToString(marker) {\n  switch (marker) {\n    case SLIDE_TITLE_OPEN:\n      return \"{slide=\";\n    case SLIDE_TITLE_CLOSE:\n      return \"}\";\n    case SLIDE_CLOSE:\n      return \"{/slide}\";\n    default:\n      return marker;\n  }\n}\n\nconst slide = (node, options) => {\n  if (!node.isValid) {\n    // not inside an [accordion] tag\n    return [\n      toOriginalStartTag(node, options.data.raw),\n      ...node.content,\n      toOriginalEndTag(node, options.data.raw),\n    ];\n  }\n  const attrs = preprocessAttr(node, options.data.raw);\n  let title = [attrs.title || attrs._default || \"Slide\"];\n  let isOpen = !!attrs.open || false;\n  let titleAlign = attrs.left ? \"left\" : attrs.right ? \"right\" : attrs.center ? \"center\" : \"left\";\n  if (node.customTitle?.length) {\n    // slide was created from markers\n    title = node.customTitle;\n    // pull out old options from title if they exist\n    const possibleOptions = title\n      .filter((t) => typeof t === \"string\")\n      .join(\"\")\n      .toLowerCase()\n      .split(\"|\")\n      .map((s) => s.trim());\n    if (possibleOptions.includes(\"open\")) {\n      isOpen = true;\n    }\n    if (possibleOptions.includes(\"right\")) {\n      titleAlign = \"right\";\n    }\n    if (possibleOptions.includes(\"center\")) {\n      titleAlign = \"center\";\n    }\n    if (possibleOptions.includes(\"left\")) {\n      titleAlign = \"left\";\n    }\n    title = title.map((t) => {\n      if (isStringNode(t)) {\n        t = t.replace(/\\|(open|right|center|left)/gi, \"\");\n      }\n      return t;\n    });\n  }\n  return [\n    toNode(\"details\", { class: \"bb-slide\", open: isOpen }, [\n      toNode(\n        \"summary\",\n        { class: \"bb-slide-title\", style: `text-align: ${titleAlign}; ${attrs.style || \"\"}` },\n        title,\n      ),\n      toNode(\"div\", { class: \"bb-slide-content\" }, node.content),\n    ]),\n  ];\n};\n\nexport const accordionTags = { accordion, slide };\n","import { toNode } from \"../utils/common\";\n/**\n * @file Adds [left], [center], and [right] to bbcode\n * @example [center]content[/center]\n */\nexport const alignment = {\n  left: (node) => toNode(\"div\", { class: \"bb-left\" }, node.content),\n  center: (node) => toNode(\"div\", { class: \"bb-center\" }, node.content),\n  right: (node) => toNode(\"div\", { class: \"bb-right\" }, node.content),\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n/**\n * @file Adds [a] and [goto] to bbcode\n * @example [a=your_anchor_name]An anchor[/a] [goto=your_anchor_name]Jump to an anchor[/goto]\n */\nexport const anchor = {\n  // name is not valid in HTML5; however, it correctly displays back while id does not\n  a: (node, options) => {\n    const attrs = preprocessAttr(node, options.data.raw)._default || \"\";\n    return toNode(\n      \"a\",\n      { id: `user-anchor-${attrs.trim()}`, name: `user-anchor-${attrs.trim()}` },\n      node.content,\n    );\n  },\n  goto: (node, options) => {\n    const attrs = preprocessAttr(node, options.data.raw)._default || \"\";\n    return toNode(\"a\", { href: `#user-anchor-${attrs.trim()}` }, node.content);\n  },\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\nconst WEB_FONTS = [\n  \"arial\",\n  \"book antiqua\",\n  \"courier new\",\n  \"georgia\",\n  \"tahoma\",\n  \"times new roman\",\n  \"trebuchet ms\",\n  \"verdana\",\n];\nconst VALID_FONT_STYLES = {\n  thin: \"100\",\n  extralight: \"200\",\n  light: \"300\",\n  regular: \"400\",\n  medium: \"500\",\n  semibold: \"600\",\n  bold: \"700\",\n  extrabold: \"800\",\n  black: \"900\",\n};\n// registered axis tags https://learn.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg#registered-axis-tags\nconst REGISTERED_AXIS = [\"ital\", \"opsz\", \"slnt\", \"wdth\", \"wght\"];\n\nconst AXES_REGEX = /(?<named_weight>[a-zA-Z]*)?\\s?(?<weight>[0-9]*)?\\s?(?<italic>italic)?/;\n\nconst axesParser = (attrs) => {\n  let axes = {\n    ital: 0,\n    wght: 400,\n  };\n\n  if (attrs?.style) {\n    // user just copy pasted the name of the style on the google font site, probably\n    const style = attrs.style.trim().toLowerCase();\n    const matches = AXES_REGEX.exec(style).groups || {};\n    if (matches?.italic) {\n      axes.ital = 1;\n    }\n\n    const weight = matches.weight;\n    if (weight && weight >= 0 && weight <= 900) {\n      axes.wght = weight;\n    } else if (Object.keys(VALID_FONT_STYLES).includes(matches.named_weight || \"\")) {\n      axes.wght = VALID_FONT_STYLES[matches.named_weight];\n    }\n\n    axes = {\n      ...axes,\n      ...Object.fromEntries(Object.entries(attrs).filter(([key]) => REGISTERED_AXIS.includes(key))),\n    };\n  }\n  return axes;\n};\n\n/**\n * Create google font api url\n * @param {string} family name of font\n * @param {object<string, string>} axes custom font axes\n */\nconst googleFontApiBuild = (family, axes) => {\n  family = family.replaceAll(\" \", \"+\");\n  // google fonts requires axes names to be in alphabetical order\n  axes = Object.keys(axes)\n    .sort()\n    .reduce((obj, key) => {\n      obj[key] = axes[key];\n      return obj;\n    }, {});\n  const axesList = Object.keys(axes).join(\",\") + \"@\" + Object.values(axes).join(\",\");\n  return \"https://fonts.googleapis.com/css2?family=\" + family + \":\" + axesList;\n};\n\nexport const font = (node, options) => {\n  const attrs = preprocessAttr(node, options.data.raw);\n  const fontFamily = attrs?._default || attrs.family || attrs.name;\n  if (fontFamily.trim() === \"\") {\n    return node.content;\n  }\n  if (WEB_FONTS.includes(fontFamily.trim().toLowerCase())) {\n    return toNode(\"span\", { style: `font-family: '${fontFamily}'` }, node.content);\n  }\n\n  const axes = axesParser(attrs);\n  const url = googleFontApiBuild(fontFamily, axes);\n  options.data.fonts.add(url);\n\n  const italic = axes.ital === 1 ? \"italic\" : \"normal\";\n\n  const custom = Object.entries(axes).filter(([key]) => key !== \"wght\" && key !== \"ital\");\n  let fontVar = \"\";\n  if (custom.length) {\n    fontVar =\n      \"font-variation-settings: \" + custom.map(([key, val]) => `'${key}' ${val}`).join(\", \") + \";\";\n  }\n\n  return toNode(\n    \"span\",\n    {\n      style: `font-family: '${fontFamily}'; font-weight: ${axes.wght}; font-style: ${italic}; ${fontVar}`,\n      \"data-font\": url,\n    },\n    node.content,\n  );\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * Parse the user provided height and return a valid height value\n * @param {Number} heightValue obtains the input of the user entered height (default is 700)\n * @returns A validated number less than 0.\n */\nfunction parseHeight(heightValue) {\n  const maxHeight = 700;\n  const parsedHeight =\n    heightValue && heightValue.trim() !== \"\" ? heightValue.replace(/[^\\d.]/g, \"\") : 0;\n\n  if (parsedHeight && parsedHeight >= 0 && parsedHeight <= maxHeight) {\n    return parsedHeight;\n  } else {\n    // if the value = 0 then nothing will be returned\n    return parsedHeight === 0 ? 0 : maxHeight;\n  }\n}\n\n/**\n * @file Adds [heightrestrict] to bbcode\n * @example [heightrestrict=50]content[/heightrestrict]\n */\nexport const heightrestrict = (node) => {\n  const attrs = preprocessAttr(node)._default;\n  const heightInput = parseHeight(attrs).toString();\n  // Return image's default size if heightrestrict did not involve a valid value\n  return heightInput === \"0\"\n    ? toNode(\"div\", { class: \"bb-height-restrict\" }, node.content)\n    : toNode(\n        \"div\",\n        { class: \"bb-height-restrict\", style: `height: ${heightInput}px;` },\n        node.content,\n      );\n};\n","import { toNode } from \"../utils/common\";\n/**\n * @file Adds [mail] to bbcode\n * @param {string} [type=\"send\"] Denotes type of mail either send or receive\n * @param {string} [person=\"Unknown\"] Denotes the person in the To/From field\n * @param {string} [subject=\"Empty\"] Denotes the subject line of the email\n * @example [mail type=\"send\" person=\"John Doe\" subject=\"Hello World\"]content[/mail]\n */\n\nconst parseEmailContent = (content) => {\n  return toNode(\"div\", { class: \"bb-email-content\" }, content);\n};\n\nconst parseEmailSubject = (subject) => {\n  return toNode(\"div\", { class: \"bb-email-subject\" }, subject);\n};\n\nconst parseEmailPerson = (person) => {\n  return toNode(\"div\", { class: \"bb-email-address\" }, person);\n};\n\nconst emailHeader = toNode(\"div\", { class: \"bb-email-header\" }, \"\");\nconst emailFooter = toNode(\n  \"div\",\n  { class: \"bb-email-footer\" },\n  toNode(\"div\", { class: \"bb-email-button\" }, \"\"),\n);\n\nexport const mail = (node) => {\n  const attributes = node.attrs;\n  let mailAttr = {\n    mailOption: (attributes.type || \"send\").toLowerCase(),\n    person: attributes.person || \"Unknown\",\n    subject: attributes.subject || \"Empty\",\n  };\n\n  return toNode(\n    \"div\",\n    {\n      class: \"bb-email\",\n      \"data-bb-email\": mailAttr.mailOption,\n    },\n    [\n      emailHeader,\n      parseEmailPerson(mailAttr.person),\n      parseEmailSubject(mailAttr.subject),\n      parseEmailContent(node.content),\n      emailFooter,\n    ],\n  );\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * @file Adds [row][column] to bbcode\n * @example Adds [row][column][/column][/row]\n */\nexport const rowcolumn = {\n  row: (node) => toNode(\"div\", { class: \"bb-row\" }, node.content),\n  column: (node, options) => {\n    const columnAttrs = preprocessAttr(node, options.data.raw)._default || \"8\";\n    const columnStyle = columnAttrs.startsWith(\"span\")\n      ? `column-width-${columnAttrs}`\n      : `column-width-span${columnAttrs}`;\n    return toNode(\"div\", { class: `bb-column`, \"data-span\": columnStyle }, node.content);\n  },\n};\n","import { preprocessAttr } from \"../utils/common\";\n\nconst EVENTS = [\n  \"init\",\n  \"click\",\n  \"change\",\n  \"input\",\n  \"dblclick\",\n  \"mouseenter\",\n  \"mouseleave\",\n  \"scroll\",\n];\n\n/**\n * Script tag\n *\n * [script]content[/script]\n *\n * [script class=\"id\" on=\"event\" version=\"2\"]content[/script]\n */\nexport const script = (node, options) => {\n  const attrs = preprocessAttr(node, options.data.raw);\n\n  if (!options.data.previewing && !options.data.commonGUID) {\n    // create a common GUID for the post\n    // only applicable for div, style, and script tags\n    // this is to prevent the same class name from being used in different posts\n    options.data.commonGUID = \"post-\" + Math.random().toString(36).substring(2, 7);\n  }\n  const classSuffix = options.data.previewing ? \"preview\" : options.data.commonGUID;\n\n  const onEvent =\n    (EVENTS.includes(attrs.on?.toLowerCase() || \"init\") && attrs.on?.toLowerCase()) || \"init\";\n\n  const scriptSetup = {\n    id: classSuffix,\n    class: attrs.class || \"\",\n    on: onEvent,\n    version: attrs.version || \"\",\n    content: node.content.join(\"\"),\n  };\n  options.data.bbscripts.push(scriptSetup);\n\n  return [];\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * Parses an inputted size value and returns the formatted valid font size\n * @param {string} fontValue the input of the size\n */\nfunction parseFontSize(fontValue) {\n  let value;\n  let fontSize = { valid: true };\n  const parsedSize = /(\\d+\\.?\\d?)(px|rem)?/i.exec(fontValue);\n  const sizeRanges = {\n    px_max: 36,\n    px_min: 8,\n    rem_max: 3,\n    rem_min: 0.2,\n    unitless_max: 7,\n    unitless_min: 1,\n  };\n\n  if (parsedSize && (value = parsedSize[1])) {\n    fontSize.unit = (parsedSize[2] || \"\").toLowerCase();\n    switch (fontSize.unit) {\n      case \"px\":\n        if (value > sizeRanges.px_max) {\n          value = sizeRanges.px_max;\n        } else if (value < sizeRanges.px_min) {\n          value = sizeRanges.px_min;\n        }\n        break;\n      case \"rem\":\n        if (value > sizeRanges.rem_max) {\n          value = sizeRanges.rem_max;\n        } else if (value < sizeRanges.rem_min) {\n          value = sizeRanges.rem_min;\n        }\n        break;\n      default:\n        if ((fontSize.valid = fontValue.length === value.length)) {\n          if (value > sizeRanges.unitless_max) {\n            value = sizeRanges.unitless_max;\n          } else if (value < sizeRanges.unitless_min) {\n            value = sizeRanges.unitless_min;\n          }\n        }\n        break;\n    }\n\n    fontSize.value = value;\n  }\n  return fontSize;\n}\n\nexport const size = (node) => {\n  const input = preprocessAttr(node)._default;\n  const fontSize = parseFontSize(input);\n  if (!fontSize.valid) {\n    return node.content;\n  }\n  let outputAttr = {};\n  if (fontSize.unit) {\n    outputAttr = { style: `font-size: ${fontSize.value}${fontSize.unit}` };\n  } else {\n    outputAttr = { \"data-size\": fontSize.value };\n  }\n  return toNode(\"span\", outputAttr, node.content);\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * @file Adds textmessage to bbcode\n * @exmaple [textmessage=Recipient][message=them]Hi [/message][message=me] Hey![/message][/textmessage]\n */\n\nconst ACCEPTED_OPTIONS = [\"me\", \"them\", \"right\", \"left\"];\nexport const textmessage = {\n  textmessage: (node, options) => {\n    const attr = preprocessAttr(node, options.data.raw)._default || \"Recipient\";\n    const recipient = attr && attr.trim() !== \"\" ? attr : \"Recipient\";\n    return toNode(\"div\", { class: \"bb-textmessage\" }, [\n      toNode(\"div\", { class: \"bb-textmessage-name\" }, recipient),\n      toNode(\"div\", { class: \"bb-textmessage-overflow\" }, [\n        toNode(\"div\", { class: \"bb-textmessage-content\" }, node.content),\n      ]),\n    ]);\n  },\n  message: (node, options) => {\n    let option = preprocessAttr(node, options.data.raw)._default.toLowerCase();\n    if (!ACCEPTED_OPTIONS.includes(option) || option === \"right\") {\n      option = \"me\";\n    }\n    if (option === \"left\") {\n      option = \"them\";\n    }\n\n    const senderAttrs = option === \"me\" ? \"bb-message-me\" : \"bb-message-them\";\n    return toNode(\"div\", { class: senderAttrs }, [\n      toNode(\"div\", { class: \"bb-message-content\" }, node.content),\n    ]);\n  },\n};\n","import { createPreset } from \"@bbob/preset\";\nimport { accordionTags } from \"./tags/accordion\";\nimport { alignment } from \"./tags/alignment\";\nimport { anchor } from \"./tags/anchor\";\nimport { animation, keyframe } from \"./tags/animation\";\nimport { bg } from \"./tags/background\";\nimport { block } from \"./tags/block\";\nimport { blockquote } from \"./tags/blockquote\";\nimport { border } from \"./tags/border\";\nimport { centerblock } from \"./tags/centerblock\";\nimport { check } from \"./tags/check\";\nimport { classStyle } from \"./tags/class\";\nimport { code, icode, savenl } from \"./tags/code\";\nimport { color } from \"./tags/color\";\nimport { comment } from \"./tags/comment\";\nimport { bold, italic, strike, underline } from \"./tags/discourse-core-replacement\";\nimport { div } from \"./tags/div\";\nimport { divide } from \"./tags/divide\";\nimport { fieldset } from \"./tags/fieldset\";\nimport { font } from \"./tags/font\";\nimport { fa } from \"./tags/fontawesome\";\nimport { h, h1, h2, h3, h4, h5, h6, sh } from \"./tags/header\";\nimport { heightrestrict } from \"./tags/heightrestrict\";\nimport { highlight } from \"./tags/highlight\";\nimport { imagefloat } from \"./tags/imagefloat\";\nimport { justify } from \"./tags/justify\";\nimport { br, nobr } from \"./tags/lineBreak\";\nimport { mail } from \"./tags/mail\";\nimport { newspaper } from \"./tags/newspaper\";\nimport { note } from \"./tags/note\";\nimport { ooc } from \"./tags/ooc\";\nimport { pindent } from \"./tags/pindent\";\nimport { plain } from \"./tags/plain\";\nimport { print } from \"./tags/print\";\nimport { progress } from \"./tags/progress\";\nimport { quote } from \"./tags/quote\";\nimport { rowcolumn } from \"./tags/rowcolumn\";\nimport { script } from \"./tags/script\";\nimport { scroll } from \"./tags/scroll\";\nimport { side } from \"./tags/side\";\nimport { size } from \"./tags/size\";\nimport { inlinespoiler, spoiler } from \"./tags/spoiler\";\nimport { sub } from \"./tags/subscript\";\nimport { sup } from \"./tags/superscript\";\nimport { tab, tabs } from \"./tags/tabs\";\nimport { textmessage } from \"./tags/textmessage\";\nimport { thinprogress } from \"./tags/thinprogress\";\n\nconst tags = {\n  ...accordionTags,\n  ...alignment,\n  ...anchor,\n  animation,\n  bg,\n  block,\n  blockquote,\n  border,\n  br,\n  centerblock,\n  check,\n  class: classStyle,\n  code,\n  color,\n  comment,\n  div,\n  divide,\n  fieldset,\n  fa,\n  font,\n  h,\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6,\n  heightrestrict,\n  highlight,\n  icode,\n  imagefloat,\n  inlinespoiler,\n  justify,\n  keyframe,\n  mail,\n  newspaper,\n  nobr,\n  note,\n  ooc,\n  pindent,\n  plain,\n  print,\n  progress,\n  quote,\n  ...rowcolumn,\n  thinprogress,\n  savenl,\n  sh,\n  script,\n  scroll,\n  side,\n  size,\n  spoiler,\n  sub,\n  sup,\n  tab,\n  tabs,\n  ...textmessage,\n\n  // discourse core replacement tags\n  b: bold,\n  i: italic,\n  u: underline,\n  s: strike,\n};\n\nconst availableTags = Object.keys(tags);\nconst preventParsing = [\"plain\", \"code\", \"icode\", \"class\", \"fa\"];\n\nconst preset = createPreset(tags);\n\nexport { availableTags, tags, preset, preventParsing };\nexport default preset;\n","import { isStringNode, isTagNode } from \"@bbob/plugin-helper\";\nimport { preprocessAttr, toOriginalEndTag, toOriginalStartTag } from \"../utils/common\";\n\n/**\n * Renders css Keyframes\n *\n * [animation=name][keyframe=0]color: red[/keyframe][/animation]\n */\nexport const animation = (node, options) => {\n  if (!options.data.previewing && !options.data.commonGUID) {\n    // create a common GUID for the post\n    // only applicable for div, style, and script tags\n    // this is to prevent the same class name from being used in different posts\n    options.data.commonGUID = \"post-\" + Math.random().toString(36).substring(2, 7);\n  }\n  const commonId = options.data.previewing ? \"preview\" : options.data.commonGUID;\n\n  const name = preprocessAttr(node, options.data.raw)?._default || \"\";\n  const keyframes = node.content\n    .filter((n) => isTagNode(n) && n.tag === \"keyframe\")\n    .map((content) => {\n      content.isValid = true;\n      /** @type {string} */\n      const ident = preprocessAttr(content, options.data.raw)._default || \"\";\n      content.ident = ident + (ident.match(/^\\d+$/) ? \"%\" : \"\");\n      const cleanContent = content.content\n        .filter(isStringNode)\n        .join(\"\")\n        .replaceAll(/[\\[\\]\\{\\}]/g, \"\");\n      content.formatted = `${content.ident}{ ${cleanContent} }`;\n      return content;\n    });\n  const keyframeContent = keyframes.map((n) => n.formatted).join(\"\\n\");\n  const content = `@keyframes ${commonId}${name} { ${keyframeContent} }`;\n  options.data.styles.push(content);\n  return [];\n};\n\nexport const keyframe = (node, options) => {\n  if (!node.isValid) {\n    return [\n      toOriginalStartTag(node, options.data.raw),\n      ...node.content,\n      toOriginalEndTag(node, options.data.raw),\n    ];\n  }\n  return [];\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * Add [bg] tag\n * @example [bg=red]Hello[/bg]\n */\nexport const bg = (node, options) => {\n  const color = preprocessAttr(node, options.data.raw)._default;\n  return toNode(\n    \"div\",\n    {\n      style: `background-color: ${color};`,\n      class: \"bb-background\",\n    },\n    node.content,\n  );\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * Add [block] tag\n * @example [block=treasure]content[/block]\n */\nexport const block = (node, options) => {\n  const defaultOp = \"block\";\n  const blockAttr = (preprocessAttr(node, options.data.raw)._default || defaultOp).toLowerCase();\n\n  const OPTIONS = [\n    \"block\",\n    \"dice\",\n    \"dice10\",\n    \"setting\",\n    \"warning\",\n    \"storyteller\",\n    \"announcement\",\n    \"important\",\n    \"question\",\n    \"encounter\",\n    \"information\",\n    \"character\",\n    \"treasure\",\n  ];\n\n  // Default to block option if user did not provide anything valid\n  const blockOption = OPTIONS.includes(blockAttr) ? blockAttr : defaultOp;\n\n  return toNode(\"table\", { class: \"bb-block\", \"data-bb-block\": blockOption }, [\n    toNode(\"tbody\", [\n      toNode(\"tr\", [\n        toNode(\"td\", { class: \"bb-block-icon\" }),\n        toNode(\"td\", { class: \"bb-block-content\" }, node.content),\n      ]),\n    ]),\n  ]);\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * @file Adds [blockquote] to bbcode\n * @example [blockquote=author]content[/blockquote]\n */\nexport const blockquote = (node, options) => {\n  const author = preprocessAttr(node, options.data.raw)._default || \"\";\n\n  return toNode(\"div\", { class: \"bb-blockquote\" }, [\n    toNode(\"div\", { class: \"bb-blockquote-left\" }),\n    toNode(\"div\", { class: \"bb-blockquote-content\" }, [\n      node.content,\n      toNode(\"div\", { class: \"bb-blockquote-speaker\" }, author !== \"\" ? `- ${author}` : \"\"),\n    ]),\n    toNode(\"div\", { class: \"bb-blockquote-right\" }),\n  ]);\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\nexport const border = (node, options) => {\n  const val = preprocessAttr(node, options.data.raw)._default;\n  return toNode(\n    \"div\",\n    {\n      style: `border: ${val};`,\n      class: \"bb-border\",\n    },\n    node.content,\n  );\n};\n","import { toNode } from \"../utils/common\";\n\n/**\n * Creates a line break html <br/> tag\n */\nexport const br = () => {\n  return toNode(\"br\", {}, null);\n};\n\n/**\n * Disables line breaks for given content\n * @example\n * ```\n * [nobr]test\n * test\n * test\n * [/nobr]\n *\n * test test test\n * ```\n */\nexport const nobr = (node) => {\n  return { disableLineBreakConversion: true, content: node.content };\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\nexport const centerblock = (node, options) => {\n  const percentageInput = preprocessAttr(node, options.data.raw)._default || \"50\";\n  return toNode(\"div\", { style: `margin: 0 auto; width: ${percentageInput}%` }, node.content);\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\nexport const check = (node, options) => {\n  const attrs = preprocessAttr(node, options.data.raw)._default || \"dot\";\n  return toNode(\"div\", { class: `bb-check`, \"data-type\": attrs }, node.content);\n};\n","import { isStringNode } from \"@bbob/plugin-helper\";\nimport { preprocessAttr } from \"../utils/common\";\n\n/**\n * Class style tag\n *\n * [class=name]content[/class]\n * [class name=\"className\" state=\"psuedo-class\" minWidth=\"\" maxWidth=\"\"]content[/class]\n * [class name=\"className\" selector=\"\"]content[/class]\n */\nexport const classStyle = (node, options) => {\n  const attrs = preprocessAttr(node);\n  const nameAttr = attrs.name || attrs._default;\n\n  if (!options.data.previewing && !options.data.commonGUID) {\n    // create a common GUID for the post\n    // only applicable for div, style, and script tags\n    // this is to prevent the same class name from being used in different posts\n    options.data.commonGUID = \"post-\" + Math.random().toString(36).substring(2, 7);\n  }\n  const classSuffix = options.data.previewing ? \"preview\" : options.data.commonGUID;\n  const className = nameAttr + \"__\" + classSuffix;\n  const content = node.content\n    .filter(isStringNode)\n    .map((s) => s.replaceAll(\"{post_id}\", classSuffix).replaceAll(/[\\[\\]\\{\\}]/g, \"\"));\n  let selector = \"\";\n  const mediaQuery = [];\n  if (\n    [\"hover\", \"focus\", \"active\", \"focus-within\", \"focus-visible\"].includes(\n      attrs.state?.toLowerCase(),\n    )\n  ) {\n    selector = \":\" + attrs.state.toLowerCase();\n  }\n  if (attrs.selector) {\n    selector = attrs.selector.replace(/[,{}\\\\\\n]/g, \"\");\n  }\n  if (attrs.minWidth?.match(/^[0-9]+[a-z]+$/)) {\n    // @media (min-width: )\n    mediaQuery.push(`(min-width: ${attrs.minWidth})`);\n  }\n  if (attrs.maxWidth?.match(/^[0-9]+[a-z]+$/)) {\n    // @media (max-width: )\n    mediaQuery.push(`(max-width: ${attrs.maxWidth})`);\n  }\n\n  content.unshift(`.${className}${selector} {`);\n  content.push(\"}\");\n  if (mediaQuery.length) {\n    content.unshift(`@media ${mediaQuery.join(\" and \")} {`);\n    content.push(\"}\");\n  }\n  options.data.styles.push(content.join(\"\"));\n\n  return [];\n};\n","import { preprocessAttr } from \"../utils/common\";\n\n/**\n * processes [code] tag and returns a fenced code block\n */\nexport const code = (node) => {\n  const lang = preprocessAttr(node)._default || \"bbcode\";\n  return {\n    isWhitespaceSensitive: true,\n    content: [\"```\" + lang + \"\\n\", node.content, \"\\n```\\n\"],\n  };\n};\n\n/**\n * processes [icode] tag and returns inline code\n */\nexport const icode = (node) => {\n  return {\n    isWhitespaceSensitive: true,\n    content: [\"`\", node.content, \"`\"],\n  };\n};\n\n/**\n * Special tag to save newlines in code blocks. Used for hoisting code blocks\n */\nexport const savenl = (node) => {\n  return {\n    isWhitespaceSensitive: true,\n    content: node.content,\n  };\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\nexport const color = (node) => {\n  const inputColor = preprocessAttr(node)._default || \"\";\n  if (inputColor.trim() === \"\") {\n    return node.content;\n  }\n  return toNode(\"span\", { style: `color: ${inputColor}` }, node.content);\n};\n","import { toNode } from \"../utils/common\";\n\n/**\n * @file Adds [comment] tag\n * @example [comment]Content[/comment]\n */\n\nconst comment = (node) => {\n  return toNode(\"span\", { class: \"hidden\" }, node.content);\n};\n\nexport { comment };\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * Adds [div] tag\n * [div=css]Content[/div]\n * [div class=\"class\" style=\"css\"]Content[/div]\n */\nexport const div = (node, options) => {\n  if (node.gen) {\n    // node is actually a generated node \"div\" made by another tag\n    // don't process it\n    return node;\n  }\n  const attrs = preprocessAttr(node, options.data.raw);\n  const style = attrs.style || attrs._default;\n  const classAttrs = attrs.class;\n  if (!classAttrs?.trim()) {\n    return toNode(\n      \"div\",\n      {\n        style,\n      },\n      node.content,\n    );\n  }\n\n  if (!options.data.previewing && !options.data.commonGUID) {\n    // create a common GUID for the post\n    // only applicable for div, style, and script tags\n    // this is to prevent the same class name from being used in different posts\n    options.data.commonGUID = \"post-\" + Math.random().toString(36).substring(2, 7);\n  }\n  const classSuffix = options.data.previewing ? \"preview\" : options.data.commonGUID;\n  const classNames = classAttrs\n    .split(\" \")\n    .map((c) => c + \"__\" + classSuffix)\n    .join(\" \");\n\n  return toNode(\n    \"div\",\n    {\n      class: classNames,\n      style,\n    },\n    node.content,\n  );\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\nexport const divide = (node) => {\n  const type = (preprocessAttr(node)._default || \"\").toLowerCase();\n  return toNode(\n    \"span\",\n    {\n      class: \"bb-divide\",\n      \"data-type\": type,\n    },\n    node.content,\n  );\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * @file Adds [fieldset] to bbcode\n * @example [fieldset=title]content[/fieldset]\n */\nexport const fieldset = (node, options) => {\n  const title = preprocessAttr(node, options.data.raw)._default || \"\";\n  return toNode(\"fieldset\", { class: \"bb-fieldset\" }, [\n    toNode(\"legend\", { class: \"bb-fieldset-legend\" }, title),\n    toNode(\"div\", { class: \"bb-fieldset\" }, node.content),\n  ]);\n};\n","import { toNode } from \"../utils/common\";\n\n/**\n * Adds [fa] tag\n * [fa]fa-icon[/fa]\n * [fa style=\"\" fa-transform=\"\"]fa-solid fa-icon[/fa]\n * [fa primary-color=\"\" secondary-color=\"\" primary-opacity=\"\" secondary-opacity=\"\" rotate-angle=\"\"]fa-duotone fa-icon[/fa]\n */\nexport const fa = (node) => {\n  const attrs = node.attrs;\n  let style = attrs.style || \"\";\n  style += attrs[\"primary-color\"] ? `--fa-primary-color: ${attrs[\"primary-color\"]};` : \"\";\n  style += attrs[\"secondary-color\"] ? `--fa-secondary-color: ${attrs[\"secondary-color\"]};` : \"\";\n  style += attrs[\"primary-opacity\"] ? `--fa-primary-opacity: ${attrs[\"primary-opacity\"]};` : \"\";\n  style += attrs[\"secondary-opacity\"]\n    ? `--fa-secondary-opacity: ${attrs[\"secondary-opacity\"]};`\n    : \"\";\n  style += attrs[\"rotate-angle\"] ? `--fa-rotate-angle: ${attrs[\"rotate-angle\"]};` : \"\";\n\n  return toNode(\n    \"i\",\n    {\n      \"data-bbcode-fa\": null,\n    },\n    [\n      toNode(\n        \"i\",\n        {\n          class: (node.content || []).join(\"\"),\n          style,\n          \"data-fa-transform\": attrs[\"fa-transform\"] || \"\",\n        },\n        [],\n      ),\n    ],\n  );\n};\n","import { toNode } from \"../utils/common\";\n\n/**\n * @file Adds Header to bbcode\n * @example [h]content[/h], [h2]content[/h2], [h3]content[/h3],\n * [h4]content[/h4], [h5]content[/h5], [h6]content[/h6].\n */\n\nconst h = (node) => {\n  return toNode(\"h1\", {}, node.content);\n};\n\nconst h1 = (node) => {\n  return toNode(\"h1\", {}, node.content);\n};\n\nconst h2 = (node) => {\n  return toNode(\"h2\", {}, node.content);\n};\n\nconst sh = (node) => {\n  return toNode(\"h2\", {}, node.content);\n};\n\nconst h3 = (node) => {\n  return toNode(\"h3\", {}, node.content);\n};\n\nconst h4 = (node) => {\n  return toNode(\"h4\", {}, node.content);\n};\n\nconst h5 = (node) => {\n  return toNode(\"h5\", {}, node.content);\n};\n\nconst h6 = (node) => {\n  return toNode(\"h6\", {}, node.content);\n};\n\nexport { h, sh, h1, h2, h3, h4, h5, h6 };\n","import { toNode } from \"../utils/common\";\n/**\n * @file Adds [highlight] to bbcode\n * @example [highlight]content[/highlight]\n */\nexport const highlight = (node) => {\n  return toNode(\"span\", { class: \"bb-highlight\" }, node.content);\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n/**\n * @file Adds [imagefloat] to bbcode\n * @exmaple [imagefloat=left]content[/imagefloat]\n */\nexport const imagefloat = (node) => {\n  const attrs = preprocessAttr(node)._default || \"\";\n  return toNode(\"div\", { class: `bb-float-${attrs}` }, node.content);\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n/**\n * @file Adds [spoiler] and [inlinespoiler] to bbcode\n *\n * Defaults to \"Spoiler\" name if no title provided\n *\n * @example `[spoiler=Title]text[/spoiler]`\n * @example `[inlinespoiler]hidden content[/inlinespoiler]\n */\n\nexport const spoiler = (node, options) => {\n  const providedTitle = preprocessAttr(node, options.data.raw)._default;\n  const title = \"Spoiler\" + (providedTitle ? `: ${providedTitle}` : \"\");\n\n  /**\n   * <details class=\"bb-spoiler\">\n   *  <summary>Title</summary>\n   *  <div class=\"bb-spoiler-content\">\n   *    lorem ipsum\n   *  </div>\n   * </details>\n   */\n  return toNode(\"details\", { class: \"bb-spoiler\" }, [\n    toNode(\"summary\", {}, title),\n    toNode(\"div\", { class: \"bb-spoiler-content\" }, node.content),\n  ]);\n};\n\nexport const inlinespoiler = (node) => {\n  return toNode(\"span\", { class: \"bb-inline-spoiler\" }, node.content);\n};\n","import { toNode } from \"../utils/common\";\n\n/**\n * @file Adds [justify] to bbcode\n * @example [justify]content[/justify]\n */\nexport const justify = (node) => {\n  return toNode(\"div\", { class: \"bb-justify\" }, node.content);\n};\n","import { toNode } from \"../utils/common\";\n/**\n * @file Adds [newspaper] to bbcode\n * @example [newspaper]content[/newspaper]\n */\nexport const newspaper = (node) => {\n  return toNode(\"div\", { class: \"bb-newspaper\" }, node.content);\n};\n","import { toNode } from \"../utils/common\";\n/**\n * @file Adds [note] to bbcode\n * @example [note]content[/note]\n */\n\nexport const note = (node) => {\n  return toNode(\"div\", { class: \"bb-note\" }, [\n    toNode(\"div\", { class: \"bb-note-tape\" }, \"\"),\n    toNode(\"div\", { class: \"bb-note-content\" }, [\n      node.content,\n      toNode(\"div\", { class: \"bb-note-footer\" }, \"\"),\n    ]),\n  ]);\n};\n","import { toNode } from \"../utils/common\";\n\n/**\n * @file Adds [ooc] to bbcode\n * @example [ooc]content[/ooc]\n */\nexport const ooc = (node) => {\n  return toNode(\n    \"div\",\n    {\n      class: \"bb-ooc\",\n    },\n    node.content,\n  );\n};\n","import { toNode } from \"../utils/common\";\n/**\n * @file Adds [pindent] to bbcode\n * @example [pindent]content[/pindent]\n */\nexport const pindent = (node) => {\n  return toNode(\"span\", { class: \"bb-pindent\" }, node.content);\n};\n","/**\n * [plain] bbcode tag that prevents parsing of inner tags\n * @example\n * ```\n * [plain]This is [b]bold[/b] and [i]italic[/i][/plain]\n * ```\n * outputs to\n * ```\n * This is [b]bold[/b] and [i]italic[/i]\n * ```\n */\nexport const plain = (node) => {\n  return node.content;\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * Add [print] tag\n * @example [print=lined]content[/print]\n */\nexport const print = (node) => {\n  const defaultOp = \"print\";\n  const printAttr = (preprocessAttr(node)._default || defaultOp).toLowerCase();\n\n  const OPTIONS = [\"print\", \"line\", \"graph\", \"parchment\"];\n\n  // Default to print if option is not valid\n  const printOption = OPTIONS.includes(printAttr) ? printAttr : defaultOp;\n\n  return toNode(\n    \"div\",\n    { class: printOption === defaultOp ? `bb-print` : `bb-print-${printOption}` },\n    node.content,\n  );\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * @file Adds [progress] to bbcode\n * @exmaple [progress=percentageInt]content[/progress]\n */\nexport const progress = (node) => {\n  const percentageInt = preprocessAttr(node)._default;\n  return toNode(\"div\", { class: \"bb-progress\" }, [\n    toNode(\"div\", { class: \"bb-progress-text\" }, node.content),\n    toNode(\"div\", { class: \"bb-progress-bar\", style: `width: calc(${percentageInt}% - 6px)` }, \"\"),\n    toNode(\"div\", { class: \"bb-progress-bar-other\" }, \"\"),\n  ]);\n};\n","import { preprocessAttr } from \"../utils/common\";\n\n/**\n * rebuild the [quote] tag so that markdown-it engine can parse it for itself\n */\nexport const quote = (node, options) => {\n  const attrs = preprocessAttr(node, options.data.raw);\n  if (node.content[0] === \"\\n\") {\n    node.content.shift();\n  }\n  return [`\\n[${node.tag}=\"${attrs._default}\"]\\n\\n`, ...node.content, \"\\n\\n[/quote]\\n\"];\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * @file Adds [thinprogress] to bbcode\n * @exmaple [thinprogress=percentageInt]content[/progthinprogressress]\n */\nexport const thinprogress = (node, options) => {\n  const percentageInt = preprocessAttr(node, options.data.raw)._default;\n  return toNode(\"div\", { class: \"bb-progress-thin\" }, [\n    toNode(\"div\", { class: \"bb-progress-text\" }, node.content),\n    toNode(\"div\", { class: \"bb-progress-bar\", style: `width: calc(${percentageInt}% - 6px)` }, \"\"),\n    toNode(\"div\", { class: \"bb-progress-bar-other\" }, \"\"),\n  ]);\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\n/**\n * Parse the user provided height and return a valid height value\n * @param {Number} heightValue obtains the input of the user entered height (default is 700)\n * @returns A validated number less than 0.\n */\nfunction parseHeight(heightValue) {\n  const maxHeight = 700;\n  const parsedHeight =\n    heightValue && heightValue.trim() !== \"\" ? heightValue.replace(/[^\\d.]/g, \"\") : 0;\n\n  if (parsedHeight && parsedHeight >= 0 && parsedHeight <= maxHeight) {\n    return parsedHeight;\n  } else {\n    // if the value = 0 then nothing will be returned\n    return parsedHeight === 0 ? 0 : maxHeight;\n  }\n}\n\n/**\n * @file Adds [scroll] to bbcode\n * @example [scroll]content[/scroll]\n */\nexport const scroll = (node, options) => {\n  const attrs = preprocessAttr(node, options.data.raw)._default;\n  const heightInput = parseHeight(attrs);\n  return toNode(\"div\", { class: \"bb-scroll\", style: `height: ${heightInput}px` }, node.content);\n};\n","import { preprocessAttr, toNode } from \"../utils/common\";\n\nexport const side = (node) => {\n  const attrs = preprocessAttr(node)._default || \"left\";\n  return toNode(\"div\", { class: \"bb-side\", \"data-side\": attrs }, node.content);\n};\n","import { toNode } from \"../utils/common\";\n\n/**\n * @file Adds subscript to BBCode\n * @example [sub]content[/sub]\n */\n\nconst sub = (node) => {\n  return toNode(\"sub\", {}, node.content);\n};\n\nexport { sub };\n","import { toNode } from \"../utils/common\";\n\n/**\n * @file Adds superscript to bbcode\n * @example [sup]content[/sup]\n */\n\nconst sup = (node) => {\n  return toNode(\"sup\", {}, node.content);\n};\n\nexport { sup };\n","import { isTagNode } from \"@bbob/plugin-helper\";\nimport {\n  generateGUID,\n  preprocessAttr,\n  toNode,\n  toOriginalEndTag,\n  toOriginalStartTag,\n} from \"../utils/common\";\n\n/**\n * @file Adds [tabs][tab] to bbcode\n * @example [tabs][tab=name 1]content[/tab][tab=name 2]content[/tab][/tabs]\n */\nexport const tabs = (node, options) => {\n  const tabsList = node.content.filter(\n    (contentNode) => isTagNode(contentNode) && contentNode.tag === \"tab\",\n  );\n  const groupId = generateGUID();\n  tabsList.forEach((tabNode) => {\n    tabNode.isValid = true;\n    tabNode.groupId = groupId;\n  });\n  if (!tabsList.length) {\n    // no [tab] tags found\n    return [\n      toOriginalStartTag(node, options.data.raw),\n      ...node.content,\n      toOriginalEndTag(node, options.data.raw),\n    ];\n  }\n  tabsList[0].open = true;\n\n  return toNode(\n    \"div\",\n    {\n      class: \"bb-tabs\",\n    },\n    tabsList,\n  );\n};\n\n/**\n * [tab=name]content[/tab]\n * [tab name=\"name\" style=\"style\"]content[/tab]\n */\nexport const tab = (node, options) => {\n  if (!node.isValid) {\n    // not inside a [tabs] tag\n    return [\n      toOriginalStartTag(node, options.data.raw),\n      ...node.content,\n      toOriginalEndTag(node, options.data.raw),\n    ];\n  }\n  const attrs = preprocessAttr(node, options.data.raw);\n  const name = attrs._default || attrs.name || \"Tab\";\n  const tabId = `tab-${name.replace(/\\W/g, \"_\")}-${generateGUID()}`;\n  return [\n    toNode(\"input\", {\n      type: \"radio\",\n      id: tabId,\n      name: \"tab-group-\" + node.groupId,\n      class: \"bb-tab\",\n      checked: node.open,\n    }),\n    toNode(\n      \"label\",\n      {\n        class: \"bb-tab-label\",\n        for: tabId,\n        style: attrs.style,\n      },\n      name,\n    ),\n    toNode(\n      \"div\",\n      {\n        class: \"bb-tab-content\",\n      },\n      node.content,\n    ),\n  ];\n};\n","/**\n * @file discourse-core-replacement.js\n * This is a dedicated file for replacing the standard Discourse BBCode tags in core.\n * In the markdown-it engine, discourse has added these bbcode tags in the inline parser.\n * However this means that if the parser detects a block level tag inside an inline tag,\n * it will not parse the inline tag.\n *\n * This file is meant to fix such scenarios by doing the parsing of bbcode tags for it.\n *\n * @example\n * [b][h]bold[/h][/b]   // this should properly parse the bold tag inside the h tag\n *\n * https://github.com/discourse/discourse/blob/d7ece61252d7671a1f124483836279b99852c08c/app/assets/javascripts/discourse-markdown-it/src/features/bbcode-inline.js\n */\nimport { toNode } from \"../utils/common\";\n\nexport const bold = (node) => {\n  return toNode(\"span\", { class: \"bbcode-b\" }, node.content);\n};\n\nexport const italic = (node) => {\n  if (node.gen) {\n    // node is actually a generated node \"i\" made by another tag\n    // don't process it\n    return node;\n  }\n  return toNode(\"span\", { class: \"bbcode-i\" }, node.content);\n};\n\nexport const underline = (node) => {\n  return toNode(\"span\", { class: \"bbcode-u\" }, node.content);\n};\n\nexport const strike = (node) => {\n  return toNode(\"span\", { class: \"bbcode-s\" }, node.content);\n};\n","import {\n  MD_BROKEN_BLOCKQUOTE,\n  MD_BROKEN_ORDERED_LIST,\n  MD_BROKEN_UNORDERED_LIST,\n  MD_NEWLINE_INJECT,\n  MD_NEWLINE_INJECT_COMMENT,\n  MD_NEWLINE_PRE_INJECT,\n} from \"./common\";\n\n/**\n * Post Processing designed to fix issues with Markdown and BBCode that the parser can't fix.\n *\n * Separate from markdown-it post processing as it'll be able to manipulate the full string.\n * @param {string} raw string from processing through both BBCode and Markdown\n * @returns post processed string\n */\nfunction removeNewlineInjects(raw) {\n  const processed = raw\n    .replaceAll(MD_NEWLINE_INJECT, \"\")\n    .replaceAll(MD_NEWLINE_PRE_INJECT, \"\")\n    .replaceAll(\"\\n\" + MD_NEWLINE_INJECT_COMMENT, \"\")\n    .replaceAll(MD_NEWLINE_INJECT_COMMENT + \"\\n\", \"\")\n    .replaceAll(MD_NEWLINE_INJECT_COMMENT, \"\"); // Remove all instances of the injected newline\n  return processed;\n}\n\nfunction cleanMultilineMDBlocks(raw) {\n  const processed = raw\n    .replaceAll(MD_BROKEN_ORDERED_LIST, \"\")\n    .replaceAll(MD_BROKEN_UNORDERED_LIST, \"\")\n    .replaceAll(MD_BROKEN_BLOCKQUOTE, \"\");\n  return processed;\n}\n\n/**\n * Injects hoisted code blocks back into the raw string\n * @param {string} raw input to inject hoisted code blocks into\n * @param {any} data contains hoist map\n * @returns string with hoisted code blocks injected\n */\nfunction renderHoistedCodeBlocks(raw, data) {\n  const hoistMap = data.hoistMap;\n  for (const [uuid, content] of Object.entries(hoistMap)) {\n    raw = raw.replaceAll(uuid, content);\n  }\n  return raw;\n}\n\n/**\n * Setups the class style tag template for the post\n * @param {string} raw\n * @param {{styles: string[]}} data - contains styles array\n * @returns string\n */\nfunction createClassStyleTagTemplate(raw, data) {\n  if (data.styles.length === 0) {\n    return raw;\n  }\n  const template = '<template data-bbcode-plus=\"class\">' + data.styles.join(\"\\n\") + \"</template>\";\n  return template + raw;\n}\n\n/**\n * Setups the script tag template for the post\n * @param {string} raw\n * @param {{\n *  bbscripts: {\n *    id: string,\n *    class: string,\n *    on: string,\n *    version: string,\n *    content: string\n *  }[]}} data - contains scripts array\n * @returns string\n */\nfunction createScriptTagTemplate(raw, data) {\n  if (data.bbscripts.length === 0) {\n    return raw;\n  }\n  const templates = data.bbscripts.map(\n    (s) =>\n      `<template data-bbcode-plus=\"script\" data-bbscript-id=\"${s.id}\" data-bbscript-class=\"${s.class}\" data-bbscript-on=\"${s.on}\" data-bbscript-ver=\"${s.version}\">${s.content}</template>`\n  );\n  return templates.join(\"\") + raw;\n}\n\n/**\n * Performs post processing on the raw string to address any necessary functionality that BBob/MD can't handle with a plugin (i.e. hoisting).\n * @param {string} raw processed input from after bbob and md\n * @param {any} data from bbob data\n * @returns final processed string\n */\nexport function postprocess(raw, data) {\n  let final = raw;\n  const postprocessors = [\n    removeNewlineInjects,\n    createClassStyleTagTemplate,\n    createScriptTagTemplate,\n    cleanMultilineMDBlocks,\n    renderHoistedCodeBlocks,\n  ];\n  for (const postprocessor of postprocessors) {\n    final = postprocessor(final, data);\n  }\n  return final;\n}\n","import { ESCAPABLES_REGEX, generateGUID, MD_TABLE_REGEX, regexIndexOf } from \"./common\";\n\n/**\n * Find all code blocks and hoist them out of the content and into a map for later insertion\n * @param {string} raw input to preprocess\n * @returns processed string and hoist map\n */\nfunction fenceCodeBlockPreprocess(content, data) {\n  /** @type {Object.<string, string>} */\n  const hoistMap = {};\n  let index = 0;\n\n  const addHoistAndReturnNewStartPoint = (cutOffStart, cutOffEnd, expected, trim = false) => {\n    const uuid = generateGUID();\n    if (cutOffEnd !== -1) {\n      hoistMap[uuid] = content.substring(cutOffStart, cutOffEnd);\n      content = content.substring(0, cutOffStart) + uuid + content.substring(cutOffEnd);\n    } else {\n      hoistMap[uuid] = content.substring(cutOffStart);\n      content = content.substring(0, cutOffStart) + uuid + expected;\n    }\n    if (trim) {\n      if (hoistMap[uuid].startsWith(\"\\n\")) {\n        hoistMap[uuid] = hoistMap[uuid].substring(1);\n      }\n      if (hoistMap[uuid].endsWith(\"\\n\")) {\n        hoistMap[uuid] = hoistMap[uuid].substring(0, hoistMap[uuid].length - 1);\n      }\n    }\n    return cutOffStart + uuid.length + expected.length;\n  };\n\n  while ((index = regexIndexOf(content, ESCAPABLES_REGEX, index)) !== -1) {\n    const match = ESCAPABLES_REGEX.exec(content.substring(index));\n    if (match.groups?.fence) {\n      const fence = match.groups.fence;\n      const fenceInfo = match.groups.fenceInfo;\n      if (content[index] === \"\\n\") {\n        // Check if the fence is not at the start of the content\n        index += 1;\n      }\n      const closingFenceRegex = new RegExp(\"\\n\" + fence + \"(\\n|$)\"); // Find the next fence. By commonmark spec, it should be the same fence length and type\n      const nextIndex = regexIndexOf(content, closingFenceRegex, index + fence.length);\n\n      const uuid = generateGUID();\n      if (nextIndex !== -1) {\n        hoistMap[uuid] = content.substring(index + fence.length + fenceInfo.length, nextIndex);\n      } else {\n        hoistMap[uuid] = content.substring(index + fence.length + fenceInfo.length);\n      }\n      // inject bbcode tag before and after the code block. This is to prevent BBob plugin from injecting newlines\n      const replacement = `[saveNL]\\n${fence}${fenceInfo}${uuid}\\n${fence}\\n[/saveNL]`;\n      content =\n        content.substring(0, index) +\n        replacement +\n        (nextIndex !== -1 ? content.substring(nextIndex + 1 + fence.length) : \"\");\n      index = index + replacement.length;\n    } else if (match.groups?.bbcode) {\n      const bbcode = match.groups.bbcode;\n      const bbcodeTag = match.groups.bbcodeTag.toLowerCase(); // coerce to lowercase for caseinsensitive matching\n      const closingTag = `[/${bbcodeTag}]`;\n      const nextIndex = content.toLowerCase().indexOf(closingTag, index + 1);\n      index = addHoistAndReturnNewStartPoint(index + bbcode.length, nextIndex, closingTag, true);\n    } else if (match.groups.backtick) {\n      const backtick = match.groups.backtick; // contains whole content\n      const tickStart = match.groups.tickStart;\n      const tickEnd = match.groups.tickEnd;\n      index = addHoistAndReturnNewStartPoint(\n        index + tickStart.length,\n        index + backtick.length - tickEnd.length,\n        tickEnd,\n      );\n    }\n  }\n\n  data.hoistMap = hoistMap;\n  return [content, data];\n}\n\n/**\n * Find all markdown table blocks and mark them to ignore newlines\n * @param {string} raw input to preprocess\n * @returns processed string\n */\nfunction mdTableBlockPreprocess(content, data) {\n  let index = 0;\n  while ((index = regexIndexOf(content, MD_TABLE_REGEX, index)) !== -1) {\n    const match = MD_TABLE_REGEX.exec(content.substring(index));\n    const table = match[0];\n    const replacement = `[saveNL]\\n${table}\\n[/saveNL]`;\n    content = content.substring(0, index) + replacement + content.substring(index + table.length);\n    index = index + replacement.length;\n  }\n  return [content, data];\n}\n\n/**\n * Preprocesses input to be formatted for bbob to intake. Handles any necessary functionality that BBob can't handle with a plugin (i.e. hoisting).\n * @param {string} raw input to preprocess\n * @returns formatted input for bbob to intake\n */\nexport function preprocessRaw(raw) {\n  let data = {};\n  const preprocessors = [fenceCodeBlockPreprocess, mdTableBlockPreprocess];\n  for (const preprocessor of preprocessors) {\n    [raw, data] = preprocessor(raw, data);\n  }\n  return [raw, data];\n}\n","import bbob from \"@bbob/core\";\nimport { render } from \"@bbob/html\";\nimport { lineBreakPlugin } from \"./plugins/lineBreak\";\nimport { preserveWhitespace } from \"./plugins/preserveWhitespace\";\nimport { removeEmptyLinePlugin } from \"./plugins/removeEmptyLinesInAttr\";\nimport { availableTags, preset, preventParsing } from \"./preset\";\nimport { postprocess } from \"./utils/postprocess\";\nimport { preprocessRaw } from \"./utils/preprocess\";\n\nconst options = {\n  onlyAllowTags: [...availableTags],\n  caseFreeTags: true,\n  contextFreeTags: preventParsing, // prevent parsing of children\n  enableEscapeTags: true,\n  onError: (err) => {\n    if (options.previewing) {\n      // eslint-disable-next-line no-console\n      console.warn(err.message, err.lineNumber, err.columnNumber);\n    }\n  },\n};\nconst presetTags = preset();\n\nexport const RpNBBCode = (code, opts) => {\n  const plugins = [presetTags];\n  if (opts.preserveWhitespace) {\n    plugins.push(preserveWhitespace());\n  }\n  plugins.push(lineBreakPlugin(), removeEmptyLinePlugin());\n  const [preprocessed, preprocessedData] = preprocessRaw(code);\n  return bbob(plugins).process(preprocessed, {\n    render,\n    ...options,\n    data: {\n      ...preprocessedData,\n      raw: preprocessed,\n      previewing: opts.previewing,\n      fonts: new Set(),\n      styles: [],\n      bbscripts: [],\n    },\n  });\n};\n\nexport { postprocess };\n","let C1 = 'C1';\nlet C2 = 'C2';\nif (process.env.NODE_ENV !== 'production') {\n    C1 = '\"parser\" is not a function, please pass to \"process(input, { parser })\" right function';\n    C2 = '\"render\" function not defined, please pass to \"process(input, { render })\"';\n}\nexport { C1, C2 };\n"],"names":["N","TAB","EQ","QUOTEMARK","SPACE","OPEN_BRAKET","CLOSE_BRAKET","SLASH","BACKSLASH","isTagNode","el","isStringNode","isEOL","keysReduce","obj","reduce","def","Object","keys","acc","key","getNodeLength","node","Array","isArray","content","count","contentNode","String","length","escapeAttrValue","value","replace","attrValue","name","JSON","stringify","attrsToString","values","arr","join","getTagAttrs","tag","params","uniqAttr","res","tagAttr","attrs","TagNode","attr","this","append","push","appendToNode","setStart","start","setEnd","end","toTagStart","openTag","closeTag","toTagEnd","toTagNode","newNode","toLowerCase","toString","r","renderContent","tagStart","create","isOf","type","constructor","TOKEN_TYPE_ID","getTokenValue","token","isTagEnd","charCodeAt","Token","isEmpty","isNaN","isText","isTag","isAttrName","isAttrValue","isStart","isEnd","getName","slice","getTagName","getValue","getLine","getColumn","getStart","getEnd","text","tokenToText","row","col","CharGrabber","skip","num","silent","c","pos","o","onSkip","hasNext","len","getCurr","s","getPos","getLength","getRest","substring","getNext","nextPos","getPrev","prevPos","isLast","includes","val","indexOf","grabWhile","condition","grabN","substrUntilChar","char","idx","source","options","createCharGrabber","WHITESPACES","SPECIAL_CHARS","isWhiteSpace","isEscapeChar","unq","str","charToRemove","charAt","trimChar","createLexer","buffer","prevCol","tokenIndex","stateMode","tagMode","contextFreeTag","tokens","Math","floor","escapeTags","enableEscapeTags","contextFreeTags","filter","Boolean","map","caseFreeTags","nestedMap","Map","onToken","RESERVED_CHARS","NOT_CHAR_TOKENS","isCharToken","checkContextFreeMode","isClosingTag","chars","emitToken","startPos","endPos","cl","p","e","createTokenOfType","nextTagState","tagChars","isSingleValueTag","masterStartPos","validAttrName","isValue","stateSpecial","validAttrValue","isQM","prevChar","nextChar","isPrevSLASH","isNextEQ","isWS","isNextWS","isSpecialChar","stateTag","currChar","substr","hasInvalidChars","isNoAttrsInTag","stateAttrs","tagStr","tagGrabber","hasSpace","stateWord","fullTagLen","fullTagName","isEscapableChar","isChar","tokenize","isTokenNested","tokenValue","has","get","status","set","NodeList","last","n","flush","pop","toArray","createList","parse","input","opts","onlyAllowTags","tokenizer","nodes","nestedNodes","tagNodes","tagNodesAttrName","nestedTagsMap","Set","isTagNested","tagName","flushTagNodes","getNodes","lastNestedNode","appendNodeAsString","isNested","forEach","item","appendNodes","handleTagStart","tagNode","from","to","add","handleTag","onError","line","column","lineNumber","columnNumber","handleTagEnd","lexer","createTokenizer","activeTagNode","attrName","handleNode","isObj","iterate","t","cb","tree","same","expected","actual","every","exp","some","call","act","ao","eo","createTree","extendedTree","messages","walk","match","expr","expression","renderNode","stripTags","render","toNode","gen","preprocessAttr","raw","vals","_default","nodeRaw","openTagParts","split","trim","startsWith","endsWith","toOriginalStartTag","toOriginalEndTag","regexIndexOf","string","regex","startpos","search","MD_NEWLINE_INJECT","MD_NEWLINE_PRE_INJECT","MD_NEWLINE_INJECT_COMMENT","URL_REGEX_SINGLE_LINE","RegExp","ESCAPABLES_REGEX","MD_TABLE_REGEX","generateGUID","d","Date","getTime","window","performance","now","random","isString","disableLineBreakConversion","reduceWordsToLines","unshift","child","splice","isWhitespaceSensitive","test","words","rightIdx","findLastIndex","w","i","numSpaces","fromCharCode","repeat","CONSECUTIVE_NEWLINE_REGEX","removeEmptyLinePlugin","process","tags","core","tagCallback","SLIDE_TITLE_OPEN","Symbol","SLIDE_TITLE_CLOSE","SLIDE_CLOSE","SLIDE_REGEX","markerToString","marker","accordionTags","accordion","groupId","markedContent","contentArr","newArr","shift","foundIndex","preContent","postContent","groups","slideTitleOpen","slideTitleClose","slideClose","generateSlideMarkersFromContent","generatedSlides","currentSlide","prevMarker","customTitle","generateSlidesFromMarkers","filteredContent","isValid","data","customSettings","lastValidAlignment","align","width","find","classes","style","class","slide","title","isOpen","open","titleAlign","left","right","center","possibleOptions","alignment","anchor","a","id","goto","href","WEB_FONTS","VALID_FONT_STYLES","thin","extralight","light","regular","medium","semibold","bold","extrabold","black","REGISTERED_AXIS","AXES_REGEX","emailHeader","emailFooter","rowcolumn","columnAttrs","columnStyle","EVENTS","ACCEPTED_OPTIONS","textmessage","recipient","message","option","animation","previewing","commonGUID","commonId","keyframes","ident","cleanContent","replaceAll","formatted","styles","bg","color","block","defaultOp","blockAttr","blockOption","blockquote","author","border","br","centerblock","percentageInput","check","nameAttr","classSuffix","className","selector","mediaQuery","state","minWidth","maxWidth","code","inputColor","comment","div","classAttrs","classNames","divide","fieldset","fa","font","fontFamily","family","axes","ital","wght","matches","exec","italic","weight","named_weight","fromEntries","entries","axesParser","url","sort","googleFontApiBuild","fonts","custom","fontVar","h","h1","h2","h3","h4","h5","h6","heightrestrict","heightInput","heightValue","parsedHeight","parseHeight","highlight","icode","imagefloat","inlinespoiler","justify","keyframe","mail","attributes","mailAttr","mailOption","person","subject","newspaper","nobr","note","ooc","pindent","plain","print","printAttr","printOption","progress","percentageInt","quote","thinprogress","savenl","sh","script","onEvent","on","scriptSetup","version","bbscripts","scroll","side","size","fontSize","fontValue","valid","parsedSize","sizeRanges","unit","parseFontSize","outputAttr","spoiler","providedTitle","sub","sup","tab","tabId","checked","for","tabs","tabsList","tabNode","b","u","availableTags","preset","createPreset","defTags","processor","presetFactory","presetExecutor","assign","extend","callback","removeNewlineInjects","cleanMultilineMDBlocks","renderHoistedCodeBlocks","hoistMap","uuid","createClassStyleTagTemplate","createScriptTagTemplate","fenceCodeBlockPreprocess","index","addHoistAndReturnNewStartPoint","cutOffStart","cutOffEnd","fence","fenceInfo","closingFenceRegex","nextIndex","replacement","bbcode","closingTag","bbcodeTag","backtick","tickStart","tickEnd","mdTableBlockPreprocess","table","err","console","warn","presetTags","plugins","preserveWhitespace","preprocessed","preprocessedData","preprocessors","preprocessor","preprocessRaw","plugs","mockRender","skipParse","parser","parseFn","renderFn","Error","plugin","newTree","html","bbob","final","postprocessors","postprocessor"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,14,65]}